<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2021/10/27/c-he-xin-bian-cheng/"/>
      <url>/2021/10/27/c-he-xin-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() {    //局部变量    int a = 10;    int b = 10;    //打印地址    cout << "局部变量a地址为： " << (int)&a << endl;    cout << "局部变量b地址为： " << (int)&b << endl;    cout << "全局变量g_a地址为： " <<  (int)&g_a << endl;    cout << "全局变量g_b地址为： " <<  (int)&g_b << endl;    //静态变量    static int s_a = 10;    static int s_b = 10;    cout << "静态变量s_a地址为： " << (int)&s_a << endl;    cout << "静态变量s_b地址为： " << (int)&s_b << endl;    cout << "字符串常量地址为： " << (int)&"hello world" << endl;    cout << "字符串常量地址为： " << (int)&"hello world1" << endl;    cout << "全局常量c_g_a地址为： " << (int)&c_g_a << endl;    cout << "全局常量c_g_b地址为： " << (int)&c_g_b << endl;    const int c_l_a = 10;    const int c_l_b = 10;    cout << "局部常量c_l_a地址为： " << (int)&c_l_a << endl;    cout << "局部常量c_l_b地址为： " << (int)&c_l_b << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果：</p><p><img src="assets/1545017602518.png" alt="1545017602518"></p><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p><p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">int * func(){    int a = 10;    return &a;}int main() {    int *p = func();    cout << *p << endl;    cout << *p << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>堆区：</strong></p><p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​        在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">int* func(){    int* a = new int(10);    return a;}int main() {    int *p = func();    cout << *p << endl;    cout << *p << endl;        system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p><p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>​    语法：<code> new 数据类型</code></p><p>​    利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><pre class="line-numbers language-c++"><code class="language-c++">int* func(){    int* a = new int(10);    return a;}int main() {    int *p = func();    cout << *p << endl;    cout << *p << endl;    //利用delete释放堆区数据    delete p;    //cout << *p << endl; //报错，释放的空间不可访问    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：开辟数组</strong></p><pre class="line-numbers language-c++"><code class="language-c++">//堆区开辟数组int main() {    int* arr = new int[10];    for (int i = 0; i < 10; i++)    {        arr[i] = i + 100;    }    for (int i = 0; i < 10; i++)    {        cout << arr[i] << endl;    }    //释放数组 delete 后加 []    delete[] arr;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">int main() {    int a = 10;    int &b = a;    cout << "a = " << a << endl;    cout << "b = " << b << endl;    b = 100;    cout << "a = " << a << endl;    cout << "b = " << b << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><pre class="line-numbers language-C++"><code class="language-C++">int main() {    int a = 10;    int b = 20;    //int &c;     //错误，引用必须初始化    int &c = a; //一旦初始化后，就不可以更改    c = b;         //这是赋值操作，不是更改引用    cout << "a = " << a << endl;    cout << "b = " << b << endl;    cout << "c = " << c << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//1. 值传递，形参不会修饰实参void mySwap01(int a, int b) {    int temp = a;    a = b;    b = temp;}//2. 地址传递，形参会修饰实参void mySwap02(int* a, int* b) {    int temp = *a;    *a = *b;    *b = temp;}//3. 引用传递，形参会修饰实参void mySwap03(int& a, int& b) {    int temp = a;    a = b;    b = temp;}int main() {    int a = 10;    int b = 20;    mySwap01(a, b);    cout << "a:" << a << " b:" << b << endl;    mySwap02(&a, &b);    cout << "a:" << a << " b:" << b << endl;    mySwap03(a, b);    cout << "a:" << a << " b:" << b << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//返回局部变量引用int& test01() {    int a = 10; //局部变量存放在四区中的栈区    return a;}//返回静态变量引用int& test02() {    static int a = 20;    //静态变量,存放在全局区,全局区上的数据在程序结束后系统释放    return a;}int main() {    //不能返回局部变量的引用    int& ref = test01();    cout << "ref = " << ref << endl;    //第一次结果正确,是因为编译器做了保留    cout << "ref = " << ref << endl;    //第二次结果错误,因为a的内存己经释放    //如果函数做左值，那么必须返回引用    int& ref2 = test02();    cout << "ref2 = " << ref2 << endl;    //:10    cout << "ref2 = " << ref2 << endl;    //:10    test02() = 1000;    cout << "ref2 = " << ref2 << endl;    //:1000    cout << "ref2 = " << ref2 << endl;    //:1000    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><pre class="line-numbers language-C++"><code class="language-C++">//发现是引用，转换为 int* const ref = &a;void func(int& ref){    ref = 100; // ref是引用，转换为*ref = 100}int main(){    int a = 10;        //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改    int& ref = a;     ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;        cout << "a:" << a << endl;    cout << "ref:" << ref << endl;        func(a);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：C++推荐用引用技术，因为语法方便，引用本质是<code>指针常量</code>，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//引用使用的场景，通常用来修饰形参，放在误操作void showValue(const int& v) {    //v += 10;    cout << v << endl;}int main() {    //int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误    //加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;    const int& ref = 10;    //ref = 100;  //加入const后不可以修改变量    cout << ref << endl;    //函数中利用常量引用防止误操作修改实参    int a = 10;    showValue(a);    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）{}</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">int func(int a, int b = 10, int c = 10) {    return a + b + c;}//注意事项//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) {    return a + b;}int main() {    cout << "ret = " << func(20, 20) << endl;    //:50    cout << "ret = " << func(100) << endl;        //:120    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型){}</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) {    cout << "this is func" << endl;}int main() {    func(10,10); //占位参数必须填补    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//函数重载需要函数都在同一个作用域下void func(){    cout << "func 的调用！" << endl;}void func(int a){    cout << "func (int a) 的调用！" << endl;}void func(double a){    cout << "func (double a)的调用！" << endl;}void func(int a ,double b){    cout << "func (int a ,double b) 的调用！" << endl;}void func(double a ,int b){    cout << "func (double a ,int b)的调用！" << endl;}//函数返回值不可以作为函数重载条件//int func(double a, int b)//{//    cout << "func (double a ,int b)的调用！" << endl;//}int main() {    func();    func(10);    func(3.14);    func(10,3.14);    func(3.14 , 10);        system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//函数重载注意事项//1、引用作为重载条件void func(int &a){    cout << "func (int &a) 调用 " << endl;}void func(const int &a){    cout << "func (const int &a) 调用 " << endl;}//2、函数重载碰到函数默认参数void func2(int a, int b = 10){    cout << "func2(int a, int b = 10) 调用" << endl;}void func2(int a){    cout << "func2(int a) 调用" << endl;}int main() {        int a = 10;    func(a); //调用无const    func(10);//调用有const    //func2(10); //碰到默认参数产生歧义，需要避免    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​    在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名{   访问权限： 属性  / 行为  };</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle{public:  //访问权限  公共的权限    //属性    int m_r;//半径    //行为    //获取到圆的周长    double calculateZC()    {        //2 * pi  * r        //获取圆的周长        return  2 * PI * m_r;    }};int main() {    //通过圆类，创建圆的对象    // c1就是一个具体的圆    Circle c1;    c1.m_r = 10; //给圆对象的半径 进行赋值操作    //2 * pi * 10 = = 62.8    cout << "圆的周长为： " << c1.calculateZC() << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//学生类class Student {public:    void setName(string name) {        m_name = name;    }    void setID(int id) {        m_id = id;    }    void showStudent() {        cout << "name:" << m_name << " ID:" << m_id << endl;    }public:    string m_name;    int m_id;};int main() {    Student stu;    stu.setName("德玛西亚");    stu.setID(250);    stu.showStudent();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//三种权限//公共权限  public     类内可以访问  类外可以访问//保护权限  protected  类内可以访问  类外不可以访问//私有权限  private    类内可以访问  类外不可以访问class Person{    //姓名  公共权限public:    string m_Name;    //汽车  保护权限protected:    string m_Car;    //银行卡密码  私有权限private:    int m_Password;public:    void func()    {        m_Name = "张三";        m_Car = "拖拉机";        m_Password = 123456;    }};int main() {    Person p;    p.m_Name = "李四";    //p.m_Car = "奔驰";  //保护权限类外访问不到    //p.m_Password = 123; //私有权限类外访问不到    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><pre class="line-numbers language-C++"><code class="language-C++">class C1{    int  m_A; //默认是私有权限};struct C2{    int m_A;  //默认是公共权限};int main() {    C1 c1;    c1.m_A = 10; //错误，访问权限是私有    C2 c2;    c2.m_A = 10; //正确，访问权限是公共    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    //姓名设置可读可写    void setName(string name) {        m_Name = name;    }    string getName()    {        return m_Name;    }    //获取年龄     int getAge() {        return m_Age;    }    //设置年龄    void setAge(int age) {        if (age < 0 || age > 150) {            cout << "你个老妖精!" << endl;            return;        }        m_Age = age;    }    //情人设置为只写    void setLover(string lover) {        m_Lover = lover;    }private:    string m_Name; //可读可写  姓名        int m_Age; //只读  年龄    string m_Lover; //只写  情人};int main() {    Person p;    //姓名设置    p.setName("张三");    cout << "姓名： " << p.getName() << endl;    //年龄设置    p.setAge(50);    cout << "年龄： " << p.getAge() << endl;    //情人设置    p.setLover("苍井");    //cout << "情人： " << p.m_Lover << endl;  //只写属性，不可以读取    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="assets/1545533548532.png" alt="1545533548532"></p><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="assets/1545533829184.png" alt="1545533829184"></p><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名(){}</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名(){}</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><pre class="line-numbers language-C++"><code class="language-C++">class Person{public:    //构造函数    Person()    {        cout << "Person的构造函数调用" << endl;    }    //析构函数    ~Person()    {        cout << "Person的析构函数调用" << endl;    }};void test01(){    Person p;}int main() {        test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​    按参数分为： 有参构造和无参构造</p><p>​    按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//1、构造函数分类// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person {public:    //无参（默认）构造函数    Person() {        cout << "无参构造函数!" << endl;    }    //有参构造函数    Person(int a) {        age = a;        cout << "有参构造函数!" << endl;    }    //拷贝构造函数    Person(const Person& p) {        age = p.age;        cout << "拷贝构造函数!" << endl;    }    //析构函数    ~Person() {        cout << "析构函数!" << endl;    }public:    int age;};//2、构造函数的调用//调用无参构造函数void test01() {    Person p; //调用无参构造函数}//调用有参的构造函数void test02() {    //2.1  括号法，常用    Person p1(10);    //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明    //Person p2();    //2.2 显式法    Person p2 = Person(10);     Person p3 = Person(p2);    //Person(10)单独写就是匿名对象  当前行结束之后，马上析构    //2.3 隐式转换法    Person p4 = 10; // Person p4 = Person(10);     Person p5 = p4; // Person p5 = Person(p4);     //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明    //Person p5(p4);}int main() {    test01();    //test02();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    Person() {        cout << "无参构造函数!" << endl;        mAge = 0;    }    Person(int age) {        cout << "有参构造函数!" << endl;        mAge = age;    }    Person(const Person& p) {        cout << "拷贝构造函数!" << endl;        mAge = p.mAge;    }    //析构函数在释放内存之前调用    ~Person() {        cout << "析构函数!" << endl;    }public:    int mAge;};//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() {    Person man(100); //p对象已经创建完毕    Person newman(man); //调用拷贝构造函数    Person newman2 = man; //拷贝构造    //Person newman3;    //newman3 = man; //不是调用拷贝构造函数，赋值操作}//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) {}void test02() {    Person p; //无参构造函数    doWork(p);}//3. 以值方式返回局部对象Person doWork2(){    Person p1;    cout << (int *)&p1 << endl;    return p1;}void test03(){    Person p = doWork2();    cout << (int *)&p << endl;}int main() {    //test01();    //test02();    test03();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li></ul><ul><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    //无参（默认）构造函数    Person() {        cout << "无参构造函数!" << endl;    }    //有参构造函数    Person(int a) {        age = a;        cout << "有参构造函数!" << endl;    }    //拷贝构造函数    Person(const Person& p) {        age = p.age;        cout << "拷贝构造函数!" << endl;    }    //析构函数    ~Person() {        cout << "析构函数!" << endl;    }public:    int age;};void test01(){    Person p1(18);    //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作    Person p2(p1);    cout << "p2的年龄为： " << p2.age << endl;}void test02(){    //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造    Person p1; //此时如果用户自己没有提供默认构造，会出错    Person p2(10); //用户提供的有参    Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供    //如果用户提供拷贝构造，编译器不会提供其他构造函数    Person p4; //此时如果用户自己没有提供默认构造，会出错    Person p5(10); //此时如果用户自己没有提供有参，会出错    Person p6(p5); //用户自己提供拷贝构造}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    //无参（默认）构造函数    Person() {        cout << "无参构造函数!" << endl;    }    //有参构造函数    Person(int age ,int height) {                cout << "有参构造函数!" << endl;        m_age = age;        m_height = new int(height);            }    //拷贝构造函数      Person(const Person& p) {        cout << "拷贝构造函数!" << endl;        //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题        m_age = p.m_age;        m_height = new int(*p.m_height);            }    //析构函数    ~Person() {        cout << "析构函数!" << endl;        if (m_height != NULL)        {            delete m_height;        }    }public:    int m_age;    int* m_height;};void test01(){    Person p1(18, 180);    Person p2(p1);    cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;    cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... {}</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    ////传统方式初始化    //Person(int a, int b, int c) {    //    m_A = a;    //    m_B = b;    //    m_C = c;    //}    //初始化列表方式初始化    Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}    void PrintPerson() {        cout << "mA:" << m_A << endl;        cout << "mB:" << m_B << endl;        cout << "mC:" << m_C << endl;    }private:    int m_A;    int m_B;    int m_C;};int main() {    Person p(1, 2, 3);    p.PrintPerson();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><pre class="line-numbers language-C++"><code class="language-C++">class A {}class B{    A a；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Phone{public:    Phone(string name)    {        m_PhoneName = name;        cout << "Phone构造" << endl;    }    ~Phone()    {        cout << "Phone析构" << endl;    }    string m_PhoneName;};class Person{public:    //初始化列表可以告诉编译器调用哪一个构造函数    Person(string name, string pName) :m_Name(name), m_Phone(pName)    {        cout << "Person构造" << endl;    }    ~Person()    {        cout << "Person析构" << endl;    }    void playGame()    {        cout << m_Name << " 使用" << m_Phone.m_PhoneName << " 牌手机! " << endl;    }    string m_Name;    Phone m_Phone;};void test01(){    //当类中成员是其他类对象时，我们称该成员为 对象成员    //构造的顺序是 ：先调用对象成员的构造，再调用本类构造    //析构顺序与构造相反    Person p("张三" , "苹果X");    p.playGame();}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li> 所有对象共享同一份数据</li><li> 在编译阶段分配内存</li><li> 类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li> 所有对象共享同一个函数</li><li> 静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><pre class="line-numbers language-C++"><code class="language-C++">class Person{    public:    static int m_A; //静态成员变量    //静态成员变量特点：    //1 在编译阶段分配内存    //2 类内声明，类外初始化    //3 所有对象共享同一份数据private:    static int m_B; //静态成员变量也是有访问权限的};int Person::m_A = 10;int Person::m_B = 10;void test01(){    //静态成员变量两种访问方式    //1、通过对象    Person p1;    p1.m_A = 100;    cout << "p1.m_A = " << p1.m_A << endl;    Person p2;    p2.m_A = 200;    cout << "p1.m_A = " << p1.m_A << endl; //共享同一份数据    cout << "p2.m_A = " << p2.m_A << endl;    //2、通过类名    cout << "m_A = " << Person::m_A << endl;    //cout << "m_B = " << Person::m_B << endl; //私有权限访问不到}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong>静态成员函数</p><pre class="line-numbers language-C++"><code class="language-C++">class Person{public:    //静态成员函数特点：    //1 程序共享一个函数    //2 静态成员函数只能访问静态成员变量        static void func()    {        cout << "func调用" << endl;        m_A = 100;        //m_B = 100; //错误，不可以访问非静态成员变量    }    static int m_A; //静态成员变量    int m_B; // private:    //静态成员函数也是有访问权限的    static void func2()    {        cout << "func2调用" << endl;    }};int Person::m_A = 10;void test01(){    //静态成员变量两种访问方式    //1、通过对象    Person p1;    p1.func();    //2、通过类名    Person::func();    //Person::func2(); //私有权限访问不到}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    Person() {        mA = 0;    }    //非静态成员变量占对象空间    int mA;    //静态成员变量不占对象空间    static int mB;     //函数也不占对象空间，所有函数共享一个函数实例    void func() {        cout << "mA:" << this->mA << endl;    }    //静态成员函数也不占对象空间    static void sfunc() {    }};int main() {    cout << sizeof(Person) << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li> 当形参和成员变量同名时，可用this指针来区分</li><li> 在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><pre class="line-numbers language-C++"><code class="language-C++">class Person{public:    Person(int age)    {        //1、当形参和成员变量同名时，可用this指针来区分        this->age = age;    }    Person& PersonAddPerson(Person p)    {        this->age += p.age;        //返回对象本身        return *this;    }    int age;};void test01(){    Person p1(10);    cout << "p1.age = " << p1.age << endl;    Person p2(10);    p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);    cout << "p2.age = " << p2.age << endl;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//空指针访问成员函数class Person {public:    void ShowClassName() {        cout << "我是Person类!" << endl;    }    void ShowPerson() {        if (this == NULL) {            return;        }        cout << mAge << endl;    }public:    int mAge;};void test01(){    Person * p = NULL;    p->ShowClassName(); //空指针，可以调用成员函数    p->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    Person() {        m_A = 0;        m_B = 0;    }    //this指针的本质是一个指针常量，指针的指向不可修改    //如果想让指针指向的值也不可以修改，需要声明常函数    void ShowPerson() const {        //const Type* const pointer;        //this = NULL; //不能修改指针的指向 Person* const this;        //this->mA = 100; //但是this指针指向的对象的数据是可以修改的        //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量        this->m_B = 100;    }    void MyFunc() const {        //mA = 10000;    }public:    int m_A;    mutable int m_B; //可修改 可变的};//const修饰对象  常对象void test01() {    const Person person; //常量对象      cout << person.m_A << endl;    //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问    person.m_B = 100; //但是常对象可以修改mutable修饰成员变量    //常对象访问成员函数    person.MyFunc(); //常对象不能调用const的函数}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><pre class="line-numbers language-C++"><code class="language-C++">class Building{    //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容    friend void goodGay(Building * building);public:    Building()    {        this->m_SittingRoom = "客厅";        this->m_BedRoom = "卧室";    }public:    string m_SittingRoom; //客厅private:    string m_BedRoom; //卧室};void goodGay(Building * building){    cout << "好基友正在访问： " << building->m_SittingRoom << endl;    cout << "好基友正在访问： " << building->m_BedRoom << endl;}void test01(){    Building b;    goodGay(&b);}int main(){    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><pre class="line-numbers language-C++"><code class="language-C++">class Building;class goodGay{public:    goodGay();    void visit();private:    Building *building;};class Building{    //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容    friend class goodGay;public:    Building();public:    string m_SittingRoom; //客厅private:    string m_BedRoom;//卧室};Building::Building(){    this->m_SittingRoom = "客厅";    this->m_BedRoom = "卧室";}goodGay::goodGay(){    building = new Building;}void goodGay::visit(){    cout << "好基友正在访问" << building->m_SittingRoom << endl;    cout << "好基友正在访问" << building->m_BedRoom << endl;}void test01(){    goodGay gg;    gg.visit();}int main(){    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><pre class="line-numbers language-C++"><code class="language-C++">class Building;class goodGay{public:    goodGay();    void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容    void visit2(); private:    Building *building;};class Building{    //告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容    friend void goodGay::visit();public:    Building();public:    string m_SittingRoom; //客厅private:    string m_BedRoom;//卧室};Building::Building(){    this->m_SittingRoom = "客厅";    this->m_BedRoom = "卧室";}goodGay::goodGay(){    building = new Building;}void goodGay::visit(){    cout << "好基友正在访问" << building->m_SittingRoom << endl;    cout << "好基友正在访问" << building->m_BedRoom << endl;}void goodGay::visit2(){    cout << "好基友正在访问" << building->m_SittingRoom << endl;    //cout << "好基友正在访问" << building->m_BedRoom << endl;}void test01(){    goodGay  gg;    gg.visit();}int main(){        test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><pre class="line-numbers language-C++"><code class="language-C++">class Person {public:    Person() {};    Person(int a, int b)    {        this->m_A = a;        this->m_B = b;    }    //成员函数实现 + 号运算符重载    Person operator+(const Person& p) {        Person temp;        temp.m_A = this->m_A + p.m_A;        temp.m_B = this->m_B + p.m_B;        return temp;    }public:    int m_A;    int m_B;};//全局函数实现 + 号运算符重载//Person operator+(const Person& p1, const Person& p2) {//    Person temp(0, 0);//    temp.m_A = p1.m_A + p2.m_A;//    temp.m_B = p1.m_B + p2.m_B;//    return temp;//}//运算符重载 可以发生函数重载 Person operator+(const Person& p2, int val)  {    Person temp;    temp.m_A = p2.m_A + val;    temp.m_B = p2.m_B + val;    return temp;}void test() {    Person p1(10, 10);    Person p2(20, 20);    //成员函数方式    Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)    cout << "mA:" << p3.m_A << " mB:" << p3.m_B << endl;    Person p4 = p3 + 10; //相当于 operator+(p3,10)    cout << "mA:" << p4.m_A << " mB:" << p4.m_B << endl;}int main() {    test();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><pre class="line-numbers language-C++"><code class="language-C++">class Person {    friend ostream& operator<<(ostream& out, Person& p);public:    Person(int a, int b)    {        this->m_A = a;        this->m_B = b;    }    //成员函数 实现不了  p << cout 不是我们想要的效果    //void operator<<(Person& p){    //}private:    int m_A;    int m_B;};//全局函数实现左移重载//ostream对象只能有一个ostream& operator<<(ostream& out, Person& p) {    out << "a:" << p.m_A << " b:" << p.m_B;    return out;}void test() {    Person p1(10, 20);    cout << p1 << "hello world" << endl; //链式编程}int main() {    test();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><pre class="line-numbers language-C++"><code class="language-C++">class MyInteger {    friend ostream& operator<<(ostream& out, MyInteger myint);public:    MyInteger() {        m_Num = 0;    }    //前置++    MyInteger& operator++() {        //先++        m_Num++;        //再返回        return *this;    }    //后置++    MyInteger operator++(int) {        //先返回        MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；        m_Num++;        return temp;    }private:    int m_Num;};ostream& operator<<(ostream& out, MyInteger myint) {    out << myint.m_Num;    return out;}//前置++ 先++ 再返回void test01() {    MyInteger myInt;    cout << ++myInt << endl;    cout << myInt << endl;}//后置++ 先返回 再++void test02() {    MyInteger myInt;    cout << myInt++ << endl;    cout << myInt << endl;}int main() {    test01();    //test02();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Person{public:    Person(int age)    {        //将年龄数据开辟到堆区        m_Age = new int(age);    }    //重载赋值运算符     Person& operator=(Person &p)    {        if (m_Age != NULL)        {            delete m_Age;            m_Age = NULL;        }        //编译器提供的代码是浅拷贝        //m_Age = p.m_Age;        //提供深拷贝 解决浅拷贝的问题        m_Age = new int(*p.m_Age);        //返回自身        return *this;    }    ~Person()    {        if (m_Age != NULL)        {            delete m_Age;            m_Age = NULL;        }    }    //年龄的指针    int *m_Age;};void test01(){    Person p1(18);    Person p2(20);    Person p3(30);    p3 = p2 = p1; //赋值操作    cout << "p1的年龄为：" << *p1.m_Age << endl;    cout << "p2的年龄为：" << *p2.m_Age << endl;    cout << "p3的年龄为：" << *p3.m_Age << endl;}int main() {    test01();    //int a = 10;    //int b = 20;    //int c = 30;    //c = b = a;    //cout << "a = " << a << endl;    //cout << "b = " << b << endl;    //cout << "c = " << c << endl;    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Person{public:    Person(string name, int age)    {        this->m_Name = name;        this->m_Age = age;    };    bool operator==(Person & p)    {        if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)        {            return true;        }        else        {            return false;        }    }    bool operator!=(Person & p)    {        if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)        {            return false;        }        else        {            return true;        }    }    string m_Name;    int m_Age;};void test01(){    //int a = 0;    //int b = 0;    Person a("孙悟空", 18);    Person b("孙悟空", 18);    if (a == b)    {        cout << "a和b相等" << endl;    }    else    {        cout << "a和b不相等" << endl;    }    if (a != b)    {        cout << "a和b不相等" << endl;    }    else    {        cout << "a和b相等" << endl;    }}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class MyPrint{public:    void operator()(string text)    {        cout << text << endl;    }};void test01(){    //重载的（）操作符 也称为仿函数    MyPrint myFunc;    myFunc("hello world");}class MyAdd{public:    int operator()(int v1, int v2)    {        return v1 + v2;    }};void test02(){    MyAdd add;    int ret = add(10, 10);    cout << "ret = " << ret << endl;    //匿名对象调用      cout << "MyAdd()(100,100) = " << MyAdd()(100, 100) << endl;}int main() {    test01();    test02();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="assets/1544861202252.png" alt="1544861202252"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//Java页面class Java {public:    void header()    {        cout << "首页、公开课、登录、注册...（公共头部）" << endl;    }    void footer()    {        cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;    }    void left()    {        cout << "Java,Python,C++...(公共分类列表)" << endl;    }    void content()    {        cout << "JAVA学科视频" << endl;    }};//Python页面class Python{public:    void header()    {        cout << "首页、公开课、登录、注册...（公共头部）" << endl;    }    void footer()    {        cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;    }    void left()    {        cout << "Java,Python,C++...(公共分类列表)" << endl;    }    void content()    {        cout << "Python学科视频" << endl;    }};//C++页面class CPP {public:    void header()    {        cout << "首页、公开课、登录、注册...（公共头部）" << endl;    }    void footer()    {        cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;    }    void left()    {        cout << "Java,Python,C++...(公共分类列表)" << endl;    }    void content()    {        cout << "C++学科视频" << endl;    }};void test01(){    //Java页面    cout << "Java下载视频页面如下： " << endl;    Java ja;    ja.header();    ja.footer();    ja.left();    ja.content();    cout << "--------------------" << endl;    //Python页面    cout << "Python下载视频页面如下： " << endl;    Python py;    py.header();    py.footer();    py.left();    py.content();    cout << "--------------------" << endl;    //C++页面    cout << "C++下载视频页面如下： " << endl;    CPP cp;    cp.header();    cp.footer();    cp.left();    cp.content();}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>继承实现：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//公共页面class BasePage{public:    void header()    {        cout << "首页、公开课、登录、注册...（公共头部）" << endl;    }    void footer()    {        cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;    }    void left()    {        cout << "Java,Python,C++...(公共分类列表)" << endl;    }};//Java页面class Java : public BasePage{public:    void content()    {        cout << "JAVA学科视频" << endl;    }};//Python页面class Python : public BasePage{public:    void content()    {        cout << "Python学科视频" << endl;    }};//C++页面class CPP : public BasePage{public:    void content()    {        cout << "C++学科视频" << endl;    }};void test01(){    //Java页面    cout << "Java下载视频页面如下： " << endl;    Java ja;    ja.header();    ja.footer();    ja.left();    ja.content();    cout << "--------------------" << endl;    //Python页面    cout << "Python下载视频页面如下： " << endl;    Python py;    py.header();    py.footer();    py.left();    py.content();    cout << "--------------------" << endl;    //C++页面    cout << "C++下载视频页面如下： " << endl;    CPP cp;    cp.header();    cp.footer();    cp.left();    cp.content();}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="assets/clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Base1{public:     int m_A;protected:    int m_B;private:    int m_C;};//公共继承class Son1 :public Base1{public:    void func()    {        m_A; //可访问 public权限        m_B; //可访问 protected权限        //m_C; //不可访问    }};void myClass(){    Son1 s1;    s1.m_A; //其他类只能访问到公共权限}//保护继承class Base2{public:    int m_A;protected:    int m_B;private:    int m_C;};class Son2:protected Base2{public:    void func()    {        m_A; //可访问 protected权限        m_B; //可访问 protected权限        //m_C; //不可访问    }};void myClass2(){    Son2 s;    //s.m_A; //不可访问}//私有继承class Base3{public:    int m_A;protected:    int m_B;private:    int m_C;};class Son3:private Base3{public:    void func()    {        m_A; //可访问 private权限        m_B; //可访问 private权限        //m_C; //不可访问    }};class GrandSon3 :public Son3{public:    void func()    {        //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到        //m_A;        //m_B;        //m_C;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Base{public:    int m_A;protected:    int m_B;private:    int m_C; //私有成员只是被隐藏了，但是还是会继承下去};//公共继承class Son :public Base{public:    int m_D;};void test01(){    cout << "sizeof Son = " << sizeof(Son) << endl;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用工具查看：</p><p><img src="assets/1545881904150.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="assets/1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Base {public:    Base()    {        cout << "Base构造函数!" << endl;    }    ~Base()    {        cout << "Base析构函数!" << endl;    }};class Son : public Base{public:    Son()    {        cout << "Son构造函数!" << endl;    }    ~Son()    {        cout << "Son析构函数!" << endl;    }};void test01(){    //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反    Son s;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Base {public:    Base()    {        m_A = 100;    }    void func()    {        cout << "Base - func()调用" << endl;    }    void func(int a)    {        cout << "Base - func(int a)调用" << endl;    }public:    int m_A;};class Son : public Base {public:    Son()    {        m_A = 200;    }    //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数    //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域    void func()    {        cout << "Son - func()调用" << endl;    }public:    int m_A;};void test01(){    Son s;    cout << "Son下的m_A = " << s.m_A << endl;    cout << "Base下的m_A = " << s.Base::m_A << endl;    s.func();    s.Base::func();    s.Base::func(10);}int main() {    test01();    system("pause");    return EXIT_SUCCESS;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Base {public:    static void func()    {        cout << "Base - static void func()" << endl;    }    static void func(int a)    {        cout << "Base - static void func(int a)" << endl;    }    static int m_A;};int Base::m_A = 100;class Son : public Base {public:    static void func()    {        cout << "Son - static void func()" << endl;    }    static int m_A;};int Son::m_A = 200;//同名成员属性void test01(){    //通过对象访问    cout << "通过对象访问： " << endl;    Son s;    cout << "Son  下 m_A = " << s.m_A << endl;    cout << "Base 下 m_A = " << s.Base::m_A << endl;    //通过类名访问    cout << "通过类名访问： " << endl;    cout << "Son  下 m_A = " << Son::m_A << endl;    cout << "Base 下 m_A = " << Son::Base::m_A << endl;}//同名成员函数void test02(){    //通过对象访问    cout << "通过对象访问： " << endl;    Son s;    s.func();    s.Base::func();    cout << "通过类名访问： " << endl;    Son::func();    Son::Base::func();    //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问    Son::Base::func(100);}int main() {    //test01();    test02();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Base1 {public:    Base1()    {        m_A = 100;    }public:    int m_A;};class Base2 {public:    Base2()    {        m_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确    }public:    int m_A;};//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 {public:    Son()    {        m_C = 300;        m_D = 400;    }public:    int m_C;    int m_D;};//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01(){    Son s;    cout << "sizeof Son = " << sizeof(s) << endl;    cout << s.Base1::m_A << endl;    cout << s.Base2::m_A << endl;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="assets/clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p></li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Animal{public:    int m_Age;};//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal {};class Tuo   : virtual public Animal {};class SheepTuo : public Sheep, public Tuo {};void test01(){    SheepTuo st;    st.Sheep::m_Age = 100;    st.Tuo::m_Age = 200;    cout << "st.Sheep::m_Age = " << st.Sheep::m_Age << endl;    cout << "st.Tuo::m_Age = " <<  st.Tuo::m_Age << endl;    cout << "st.m_Age = " << st.m_Age << endl;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><pre class="line-numbers language-C++"><code class="language-C++">class Animal{public:    //Speak函数就是虚函数    //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。    virtual void speak()    {        cout << "动物在说话" << endl;    }};class Cat :public Animal{public:    void speak()    {        cout << "小猫在说话" << endl;    }};class Dog :public Animal{public:    void speak()    {        cout << "小狗在说话" << endl;    }};//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal & animal){    animal.speak();}////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01(){    Cat cat;    DoSpeak(cat);    Dog dog;    DoSpeak(dog);}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//普通实现class Calculator {public:    int getResult(string oper)    {        if (oper == "+") {            return m_Num1 + m_Num2;        }        else if (oper == "-") {            return m_Num1 - m_Num2;        }        else if (oper == "*") {            return m_Num1 * m_Num2;        }        //如果要提供新的运算，需要修改源码    }public:    int m_Num1;    int m_Num2;};void test01(){    //普通实现测试    Calculator c;    c.m_Num1 = 10;    c.m_Num2 = 10;    cout << c.m_Num1 << " + " << c.m_Num2 << " = " << c.getResult("+") << endl;    cout << c.m_Num1 << " - " << c.m_Num2 << " = " << c.getResult("-") << endl;    cout << c.m_Num1 << " * " << c.m_Num2 << " = " << c.getResult("*") << endl;}//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator{public :    virtual int getResult()    {        return 0;    }    int m_Num1;    int m_Num2;};//加法计算器class AddCalculator :public AbstractCalculator{public:    int getResult()    {        return m_Num1 + m_Num2;    }};//减法计算器class SubCalculator :public AbstractCalculator{public:    int getResult()    {        return m_Num1 - m_Num2;    }};//乘法计算器class MulCalculator :public AbstractCalculator{public:    int getResult()    {        return m_Num1 * m_Num2;    }};void test02(){    //创建加法计算器    AbstractCalculator *abc = new AddCalculator;    abc->m_Num1 = 10;    abc->m_Num2 = 10;    cout << abc->m_Num1 << " + " << abc->m_Num2 << " = " << abc->getResult() << endl;    delete abc;  //用完了记得销毁    //创建减法计算器    abc = new SubCalculator;    abc->m_Num1 = 10;    abc->m_Num2 = 10;    cout << abc->m_Num1 << " - " << abc->m_Num2 << " = " << abc->getResult() << endl;    delete abc;      //创建乘法计算器    abc = new MulCalculator;    abc->m_Num1 = 10;    abc->m_Num2 = 10;    cout << abc->m_Num1 << " * " << abc->m_Num2 << " = " << abc->getResult() << endl;    delete abc;}int main() {    //test01();    test02();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Base{public:    //纯虚函数    //类中只要有一个纯虚函数就称为抽象类    //抽象类无法实例化对象    //子类必须重写父类中的纯虚函数，否则也属于抽象类    virtual void func() = 0;};class Son :public Base{public:    virtual void func()     {        cout << "func调用" << endl;    };};void test01(){    Base * base = NULL;    //base = new Base; // 错误，抽象类无法实例化对象    base = new Son;    base->func();    delete base;//记得销毁}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="assets/1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">//抽象制作饮品class AbstractDrinking {public:    //烧水    virtual void Boil() = 0;    //冲泡    virtual void Brew() = 0;    //倒入杯中    virtual void PourInCup() = 0;    //加入辅料    virtual void PutSomething() = 0;    //规定流程    void MakeDrink() {        Boil();        Brew();        PourInCup();        PutSomething();    }};//制作咖啡class Coffee : public AbstractDrinking {public:    //烧水    virtual void Boil() {        cout << "煮农夫山泉!" << endl;    }    //冲泡    virtual void Brew() {        cout << "冲泡咖啡!" << endl;    }    //倒入杯中    virtual void PourInCup() {        cout << "将咖啡倒入杯中!" << endl;    }    //加入辅料    virtual void PutSomething() {        cout << "加入牛奶!" << endl;    }};//制作茶水class Tea : public AbstractDrinking {public:    //烧水    virtual void Boil() {        cout << "煮自来水!" << endl;    }    //冲泡    virtual void Brew() {        cout << "冲泡茶叶!" << endl;    }    //倒入杯中    virtual void PourInCup() {        cout << "将茶水倒入杯中!" << endl;    }    //加入辅料    virtual void PutSomething() {        cout << "加入枸杞!" << endl;    }};//业务函数void DoWork(AbstractDrinking* drink) {    drink->MakeDrink();    delete drink;}void test01() {    DoWork(new Coffee);    cout << "--------------" << endl;    DoWork(new Tea);}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名(){}</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名(){}</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Animal {public:    Animal()    {        cout << "Animal 构造函数调用！" << endl;    }    virtual void Speak() = 0;    //析构函数加上virtual关键字，变成虚析构函数    //virtual ~Animal()    //{    //    cout << "Animal虚析构函数调用！" << endl;    //}    virtual ~Animal() = 0;};Animal::~Animal(){    cout << "Animal 纯虚析构函数调用！" << endl;}//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal {public:    Cat(string name)    {        cout << "Cat构造函数调用！" << endl;        m_Name = new string(name);    }    virtual void Speak()    {        cout << *m_Name <<  "小猫在说话!" << endl;    }    ~Cat()    {        cout << "Cat析构函数调用!" << endl;        if (this->m_Name != NULL) {            delete m_Name;            m_Name = NULL;        }    }public:    string *m_Name;};void test01(){    Animal *animal = new Cat("Tom");    animal->Speak();    //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏    //怎么解决？给基类增加一个虚析构函数    //虚析构函数就是用来解决通过父类指针释放子类对象    delete animal;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">#include<iostream>using namespace std;//抽象CPU类class CPU{public:    //抽象的计算函数    virtual void calculate() = 0;};//抽象显卡类class VideoCard{public:    //抽象的显示函数    virtual void display() = 0;};//抽象内存条类class Memory{public:    //抽象的存储函数    virtual void storage() = 0;};//电脑类class Computer{public:    Computer(CPU * cpu, VideoCard * vc, Memory * mem)    {        m_cpu = cpu;        m_vc = vc;        m_mem = mem;    }    //提供工作的函数    void work()    {        //让零件工作起来，调用接口        m_cpu->calculate();        m_vc->display();        m_mem->storage();    }    //提供析构函数 释放3个电脑零件    ~Computer()    {        //释放CPU零件        if (m_cpu != NULL)        {            delete m_cpu;            m_cpu = NULL;        }        //释放显卡零件        if (m_vc != NULL)        {            delete m_vc;            m_vc = NULL;        }        //释放内存条零件        if (m_mem != NULL)        {            delete m_mem;            m_mem = NULL;        }    }private:    CPU * m_cpu; //CPU的零件指针    VideoCard * m_vc; //显卡零件指针    Memory * m_mem; //内存条零件指针};//具体厂商//Intel厂商class IntelCPU :public CPU{public:    virtual void calculate()    {        cout << "Intel的CPU开始计算了！" << endl;    }};class IntelVideoCard :public VideoCard{public:    virtual void display()    {        cout << "Intel的显卡开始显示了！" << endl;    }};class IntelMemory :public Memory{public:    virtual void storage()    {        cout << "Intel的内存条开始存储了！" << endl;    }};//Lenovo厂商class LenovoCPU :public CPU{public:    virtual void calculate()    {        cout << "Lenovo的CPU开始计算了！" << endl;    }};class LenovoVideoCard :public VideoCard{public:    virtual void display()    {        cout << "Lenovo的显卡开始显示了！" << endl;    }};class LenovoMemory :public Memory{public:    virtual void storage()    {        cout << "Lenovo的内存条开始存储了！" << endl;    }};void test01(){    //第一台电脑零件    CPU * intelCpu = new IntelCPU;    VideoCard * intelCard = new IntelVideoCard;    Memory * intelMem = new IntelMemory;    cout << "第一台电脑开始工作：" << endl;    //创建第一台电脑    Computer * computer1 = new Computer(intelCpu, intelCard, intelMem);    computer1->work();    delete computer1;    cout << "-----------------------" << endl;    cout << "第二台电脑开始工作：" << endl;    //第二台电脑组装    Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;    computer2->work();    delete computer2;    cout << "-----------------------" << endl;    cout << "第三台电脑开始工作：" << endl;    //第三台电脑组装    Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;    computer3->work();    delete computer3;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">#include <fstream>void test01(){    ofstream ofs;    ofs.open("test.txt", ios::out);    ofs << "姓名：张三" << endl;    ofs << "性别：男" << endl;    ofs << "年龄：18" << endl;    ofs.close();}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">#include <fstream>#include <string>void test01(){    ifstream ifs;    ifs.open("test.txt", ios::in);    if (!ifs.is_open())    {        cout << "文件打开失败" << endl;        return;    }    //第一种方式    //char buf[1024] = { 0 };    //while (ifs >> buf)    //{    //    cout << buf << endl;    //}    //第二种    //char buf[1024] = { 0 };    //while (ifs.getline(buf,sizeof(buf)))    //{    //    cout << buf << endl;    //}    //第三种    //string buf;    //while (getline(ifs, buf))    //{    //    cout << buf << endl;    //}    char c;    while ((c = ifs.get()) != EOF)    {        cout << c;    }    ifs.close();}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件 </li></ul><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">#include <fstream>#include <string>class Person{public:    char m_Name[64];    int m_Age;};//二进制文件  写文件void test01(){    //1、包含头文件    //2、创建输出流对象    ofstream ofs("person.txt", ios::out | ios::binary);        //3、打开文件    //ofs.open("person.txt", ios::out | ios::binary);    Person p = {"张三"  , 18};    //4、写文件    ofs.write((const char *)&p, sizeof(p));    //5、关闭文件    ofs.close();}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><pre class="line-numbers language-C++"><code class="language-C++">#include <fstream>#include <string>class Person{public:    char m_Name[64];    int m_Age;};void test01(){    ifstream ifs("person.txt", ios::in | ios::binary);    if (!ifs.is_open())    {        cout << "文件打开失败" << endl;    }    Person p;    ifs.read((char *)&p, sizeof(p));    cout << "姓名： " << p.m_Name << " 年龄： " << p.m_Age << endl;}int main() {    test01();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/10/26/hexo-bo-ke-matery-zhu-ti-mei-hua-zhi-kan-ban-niang-neng-shuo-hua-neng-huan-zhuang-qie-huan-xiao-ren/"/>
      <url>/2021/10/26/hexo-bo-ke-matery-zhu-ti-mei-hua-zhi-kan-ban-niang-neng-shuo-hua-neng-huan-zhuang-qie-huan-xiao-ren/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1、Live2D"><a href="#1-1、Live2D" class="headerlink" title="1.1、Live2D"></a>1.1、Live2D</h3><p><code>Live2D</code>是一种应用于电子游戏的绘图渲染技术，由日本<code>Cybernoids</code>公司开发，通过一系列的连续图像和人物建模来生成一种类似二维图像的三维模型，换句话说就是2D的素材实现一定程度的3D效果，但只能是一定程度3D，因为Live 2D人物无法大幅度转身。 </p><p> 很多知名的动漫都是<code>Live2D</code>游戏改编的或者反过来的，例如：《我的妹妹不可能有那么可爱》、《我的朋友很少》、《樱花庄的宠物女孩》等。 </p><p><code>ive2d</code>官方网站就是<code>live2d.com</code>，里面提供了<code>live2d</code>开发和编辑软件（如<code>Live2D Cubism editor和Live2D Euclideditor</code>），还有开发使用教程等，对相关制作感兴趣的可以看看。 </p><h3 id="2-1、看板娘"><a href="#2-1、看板娘" class="headerlink" title="2.1、看板娘"></a>2.1、看板娘</h3><p>看板娘是一种职业和习惯称呼，也是<code>ACGN</code>次文化中的萌属性之一。简而言之就是小店的女服务生，也有“吸引顾客，招揽生意，提高人气”等作用类似品牌形象代言人的含义。</p><p>模型预览：<a href="https://huaji8.top/post/live2d-plugin-2.0/">https://huaji8.top/post/live2d-plugin-2.0/</a> </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/a2d201771h112b195e741490833a54b5?fid=1789975539-250528-445956090594144&amp;time=1635300000&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-O5K0hw6wIHrhtKlGDiGMV37IFX0=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=27632489292156135&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h2 id="二、小白水平"><a href="#二、小白水平" class="headerlink" title="二、小白水平"></a>二、小白水平</h2><p>hexo的官方是支持看板娘的，已经封装好了插件，但只是模型，不能说话、不能换装、功能较少。</p><h3 id="2-1、准备工作"><a href="#2-1、准备工作" class="headerlink" title="2.1、准备工作"></a>2.1、准备工作</h3><p> 检查博客主目录下的<code>package.json</code>是否有<code>"hexo-helper-live2d"</code>：“^3.0.3”，依赖：</p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/eb0261ac5v7bff0824f136d6e30f449b?fid=1789975539-250528-968302098057694&amp;time=1635256800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-XaxNmMsn54kr8I2e/5l4yVUGhoI=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=15713094858249023&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p> 有的话可以先卸载：</p><pre class="line-numbers language-html"><code class="language-html">npm uninstall hexo-helper-live2d <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2、安装依赖"><a href="#2-2、安装依赖" class="headerlink" title="2.2、安装依赖"></a>2.2、安装依赖</h3><pre class="line-numbers language-c++"><code class="language-c++">npm install --save hexo-helper-live2d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 安装过程中可能遇到一些依赖性问题，按提示做就行 </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/46e26f128p1102e33d0c97f0033b54e3?fid=1789975539-250528-267289330636601&amp;time=1635256800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-KVTo9vrbXbq5/zCjpqEowo0GuFQ=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=15713094858249023&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p> 遇到这种就运行<code>npm audit fix</code>，如果还不成功，会提示你用<code>npm audit fix --force</code>，一般这个时候就成功了。 </p><p> 成功了之后可以看到当前目录的<code>node_modules/</code>下有个<code>live2d-widget</code>目录，这是动画的主配置： </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/9b55bfdbeh4c00e8decb6128c58b1430?fid=1789975539-250528-146705711326910&amp;time=1635256800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-P+tlauRrvviEcbuS0YWHC65GjUo=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=15713094858249023&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p>这个时候是没有模型文件的，所以下一步是下载模型文件。</p><h3 id="2-3、下载model文件"><a href="#2-3、下载model文件" class="headerlink" title="2.3、下载model文件"></a>2.3、下载model文件</h3><p>模型仓库 使用 <code>npm install {packagename}</code>命令进行下载</p><p>模型预览：<a href="https://huaji8.top/post/live2d-plugin-2.0/">https://huaji8.top/post/live2d-plugin-2.0/</a></p><p>模型下载：<a href="https://github.com/xiazeyu/live2d-widget-models">https://github.com/xiazeyu/live2d-widget-models</a> </p><p>模型文件可直接用npm安装：如下</p><pre class="line-numbers language-html"><code class="language-html">npm install live2d-widget-model-shizuku        //注意：shizuku下载对应看板娘名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>model</code>名字可在<code>live2d-widget-models</code>中找到，也可点击<code>live2d</code>看板娘模型预览来选择你喜欢的模型进行安装。<br>安装完成可以在<code>node_modules/</code>下看到<code>live2d-widget-model-shizuku</code>文件夹 </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/028511b36sc56a3d8f81fc8ba1162eb1?fid=1789975539-250528-314329912568235&amp;time=1635256800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-1fcDPTCR05It+NPkF4JqYc7jqdw=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=15713094858249023&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h3 id="2-4、添加live2d看板娘到hexo"><a href="#2-4、添加live2d看板娘到hexo" class="headerlink" title="2.4、添加live2d看板娘到hexo"></a>2.4、添加live2d看板娘到hexo</h3><p>配置<code>Hexo</code>的主<code>_config.yml</code>或者使用的主题的<code>_config.yml</code><br>添加以下代码到配置文件中： </p><pre class="line-numbers language-html"><code class="language-html"># Live2D看板娘live2d:  enable: true  pluginModelPath: assets/  model:    #模板目录，在node_modules里    use: live2d-widget-model-shizuku      //注意：shizuku运行对应看板娘名称  display:    position: right    width: 300     height: 600  mobile:    # 在手机端显示    show: false     rect:    opacity:0.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5、查看效果"><a href="#2-5、查看效果" class="headerlink" title="2.5、查看效果"></a>2.5、查看效果</h3><p> 使用<code>hexo g</code>生成文件，使用<code>hexo server</code>即可在本地查看效果： </p><pre class="line-numbers language-html"><code class="language-html"># 生成文件hexo g# 本地浏览hexo s -p 555<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/0beac66e7tbd707ce2083513d3d452fb?fid=1789975539-250528-155082100884792&amp;time=1635260400&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-NuQCcWr/X43Xhi9dbTOrtp+1SbQ=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=16621584832736266&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/e22e5615btff4b453452ffdea2963488?fid=1789975539-250528-919694749079748&amp;time=1635256800&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-gA8goq1eTn1vDd0W1fv0pLHqCsE=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=15951498484334986&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p> 打开浏览器访问：<a href="http://localhost:5555/">http://localhost:5555</a> 即可看到效果： </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/118fb79eegfee9e7c43349659ef749c7?fid=1789975539-250528-476488513659248&amp;time=1635300000&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-lxdyBG0YVplgH63MYjRhRoJpY3s=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=27632489292156135&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h3 id="2-6、发布"><a href="#2-6、发布" class="headerlink" title="2.6、发布"></a>2.6、发布</h3><p> 在本地找到满意的效果后，使用<code>hexo d</code>将其发布到你的hexo服务器上，即可在外网查看了。 </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/9b274ffaesc17833773a69a6b34b5728?fid=1789975539-250528-461505817587311&amp;time=1635260400&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-s7gZHSU9qtmnqotEaAJb6odlX9o=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=17020312558506833&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/0e2e3141bl6bd9a65bb4aab19be2d66f?fid=1789975539-250528-206781905740853&amp;time=1635260400&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-6WrzZow06zNWny4cM8LKQzdMZNw=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=17020312558506833&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h2 id="三、大神水平"><a href="#三、大神水平" class="headerlink" title="三、大神水平"></a>三、大神水平</h2><p> 大神作品，功能齐全：能说话、能换装、能玩游戏、能拍照、自动切换板娘、还能自定义。 </p><h3 id="3-1、下载文件"><a href="#3-1、下载文件" class="headerlink" title="3.1、下载文件"></a>3.1、下载文件</h3><p>GitHub： <a href="https://github.com/stevenjoezhang/live2d-widget">张书樵大神的项目</a></p><p>百度云：<a href="https://pan.baidu.com/s/1sCkzBch1avDv0hkaw7B8wg">live2d-widget-master.zip</a>  提取码：ziqi</p><p>解压到本地博客目录的 <code>themes/matrey/source</code> 下，并修改文件夹名为 <code>live2d-widget</code>，修改项目中的 <code>autoload.js</code> 文件，如下：<br><code>将 ：</code></p><pre class="line-numbers language-html"><code class="language-html">//注销//const live2d_path = "https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>修改成：</code></p><pre class="line-numbers language-html"><code class="language-html">//打开const live2d_path = "/live2d-widget/";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/c6f7ca150g01b53e28b224ea86ceee3b?fid=1789975539-250528-189886906370914&amp;time=1635249600&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Tb9kUzmrrwU42LpNCJqx+N5VjvQ=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=13264390367765744&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h3 id="3-2、新增内容"><a href="#3-2、新增内容" class="headerlink" title="3.2、新增内容"></a>3.2、新增内容</h3><p> 在<code>/themes/matrey/layout/layout.ejs</code>中，新增如下内容： </p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/live2d-widget/autoload.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/c6f7ca150g01b53e28b224ea86ceee3b?fid=1789975539-250528-189886906370914&amp;time=1635300000&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-cPbmtPZZmlFjfHmnmR02qa3G9Fw=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=27632168512831522&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h3 id="3-3、主题配置文件"><a href="#3-3、主题配置文件" class="headerlink" title="3.3、主题配置文件"></a>3.3、主题配置文件</h3><p> 在 <code>主题配置文件</code>中, <code>/themes/matrey/_config.yml</code>新增如下内容： </p><pre class="line-numbers language-html"><code class="language-html">live2d:  enable: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://thumbnail0.baidupcs.com/thumbnail/6a18c6028iae01de232e37b597a72509?fid=1789975539-250528-1067975557203980&amp;time=1635249600&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Sm9E3qTeTtlQ/IaBEBkdMrgwQLY=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=13363232879024885&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h3 id="3-4、可修改"><a href="#3-4、可修改" class="headerlink" title="3.4、可修改"></a>3.4、可修改</h3><p> 想修改看板娘大小、位置、格式、文本内容等，可查看并修改 ：<code>waifu-tips.js</code> 、 <code>waifu-tips.json</code> 和 <code>waifu.css</code>。 </p><h3 id="3-5、效果"><a href="#3-5、效果" class="headerlink" title="3.5、效果"></a>3.5、效果</h3><p>可以来我的博客看一看(*￣︶￣)： <a href="https://baiziqing.github.io/">https://baiziqing.github.io/</a> </p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/840dce293j5fa8dbf0a32c4d99481bb2?fid=1789975539-250528-466233969120453&amp;time=1635300000&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-8O1oq404kGYf9naZtmMCVDtAqtU=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=27632489292156135&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/5eda6f049t0f48cba557cc820968cf11?fid=1789975539-250528-972375583407838&amp;time=1635303600&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-prVDRyifhL6pHhALhhpRz7pOKIw=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=27838105699779010&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/80fe208cah20a4f5c4a25f574cadc1ed?fid=1789975539-250528-1078671342672383&amp;time=1635300000&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-S3TGKeWr8dWhL1RXbExN2LFkd7Q=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=27632489292156135&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++程序设计</title>
      <link href="/2021/10/25/c-cheng-xu-she-ji/"/>
      <url>/2021/10/25/c-cheng-xu-she-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://thumbnail0.baidupcs.com/thumbnail/500a1b499k9170203b3516bc6f8fcb11?fid=1789975539-250528-1050671472593170&amp;time=1635210000&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-BR7g/2FMQcf9frA6UwZuHLxI5Zc=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=2796754644589342&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h1 id="C-程序设计"><a href="#C-程序设计" class="headerlink" title="C++程序设计"></a>C++程序设计</h1><h2 id="一、从-C-到-C"><a href="#一、从-C-到-C" class="headerlink" title="一、从 C 到 C++"></a>一、从 C 到 C++</h2><h3 id="1-1、C-简介"><a href="#1-1、C-简介" class="headerlink" title="1.1、C++简介"></a>1.1、C++简介</h3><p>C语言是面向过程、C++是向对象的编程语言</p><p>C++是C的升级、面向对象</p><h3 id="1-2、C-新增特性"><a href="#1-2、C-新增特性" class="headerlink" title="1.2、C++新增特性"></a>1.2、C++新增特性</h3><h4 id="1-2-1、相对于C-C-有更为严格的类型检查"><a href="#1-2-1、相对于C-C-有更为严格的类型检查" class="headerlink" title="1.2.1、相对于C/ C++ 有更为严格的类型检查"></a>1.2.1、相对于C/ C++ 有更为严格的类型检查</h4><p>eg:<br>int *p;<br>char *q;<br>p = q; //c 语言警告， 但是c++是错误</p><h4 id="1-2-2、新增变量引用"><a href="#1-2-2、新增变量引用" class="headerlink" title="1.2.2、新增变量引用"></a>1.2.2、新增变量引用</h4><p>eg：<br>int a  = 10；<br>int &amp;b =  a;  //c语言直接报错，c++是为引用（给a 取别名 为 b）<br>printf（“%d–%d–%p–%p\n”, a,b,&amp;a, &amp;b）;<br>不能同时引用多个变量。</p><h4 id="1-2-3、支持面向对象"><a href="#1-2-3、支持面向对象" class="headerlink" title="1.2.3、支持面向对象"></a>1.2.3、支持面向对象</h4><p>类和对象、继承、多态、虚函数及RTTI（运行时类型识别）</p><h4 id="1-2-4、新增泛型编程"><a href="#1-2-4、新增泛型编程" class="headerlink" title="1.2.4、新增泛型编程"></a>1.2.4、新增泛型编程</h4><p>支持模板（template），标准模板库（STL）</p><h4 id="1-2-5、支持异常处理"><a href="#1-2-5、支持异常处理" class="headerlink" title="1.2.5、支持异常处理"></a>1.2.5、支持异常处理</h4><p>标准异常、自定义异常</p><h4 id="1-2-6、支持函数-运算符重载"><a href="#1-2-6、支持函数-运算符重载" class="headerlink" title="1.2.6、支持函数/运算符重载"></a>1.2.6、支持函数/运算符重载</h4><h4 id="1-2-7、支持名字空间"><a href="#1-2-7、支持名字空间" class="headerlink" title="1.2.7、支持名字空间"></a>1.2.7、支持名字空间</h4><p>用于管理函数名、变量名及类</p><h3 id="1-3、OOP简介"><a href="#1-3、OOP简介" class="headerlink" title="1.3、OOP简介"></a>1.3、OOP简介</h3><h4 id="1-3-1、面向对象编程（-OOP-）"><a href="#1-3-1、面向对象编程（-OOP-）" class="headerlink" title="1.3.1、面向对象编程（ OOP ）"></a>1.3.1、面向对象编程（ OOP ）</h4><p>OOP是程序设计工程化的一种方法，软件架构的一种思想。<br>OOP基本原则是程序是由单个能够起到子程序作用的单元或对象组合而成，以达到软件工程的三个主要目标：重用性、灵活性和扩展性。</p><h4 id="1-3-2、重用性"><a href="#1-3-2、重用性" class="headerlink" title="1.3.2、重用性"></a>1.3.2、重用性</h4><p>代码被重复使用，以减少代码量，就是重用性的重要指标。</p><h4 id="1-3-3、灵活性"><a href="#1-3-3、灵活性" class="headerlink" title="1.3.3、灵活性"></a>1.3.3、灵活性</h4><p>软件系统由很多可以复用的构件随意重构，以达到实现不同的功能，非常灵活。</p><h4 id="1-3-3、扩展性"><a href="#1-3-3、扩展性" class="headerlink" title="1.3.3、扩展性"></a>1.3.3、扩展性</h4><p>软件系统可以容易地新增需求，基本构件也可以轻松的扩展功能。</p><h4 id="1-3-4、面向过程设计-（c语言面向过程）"><a href="#1-3-4、面向过程设计-（c语言面向过程）" class="headerlink" title="1.3.4、面向过程设计:（c语言面向过程）"></a>1.3.4、面向过程设计:（c语言面向过程）</h4><p>程序=数据结构+算法。</p><h4 id="1-3-5、面向对象设计：（c-面向对象）"><a href="#1-3-5、面向对象设计：（c-面向对象）" class="headerlink" title="1.3.5、面向对象设计：（c++面向对象）"></a>1.3.5、面向对象设计：（c++面向对象）</h4><p>对象=数据结构+算法<br>程序=(对象+对象+….)+对象间通讯机制。</p><h4 id="1-3-6、面向对象编程主要涉及概念如下"><a href="#1-3-6、面向对象编程主要涉及概念如下" class="headerlink" title="1.3.6、面向对象编程主要涉及概念如下"></a>1.3.6、面向对象编程主要涉及概念如下</h4><p>类( class )、对象( Object )、数据抽象、继承( inherit )、动态绑定(动态联编)、静态绑定(静态联编)、数据封装( encapsulation )、多态性( polymorphism)、消息传递。</p><h3 id="1-4、泛型编程-Generic-Programming"><a href="#1-4、泛型编程-Generic-Programming" class="headerlink" title="1.4、泛型编程( Generic Programming)"></a>1.4、泛型编程( Generic Programming)</h3><p>简介：目的是为了实现C++的STL(标准模板库)。</p><h3 id="1-5、编译C-程序"><a href="#1-5、编译C-程序" class="headerlink" title="1.5、编译C++程序"></a>1.5、编译C++程序</h3><h4 id="1-5-1、C-C-编译步骤-★★★"><a href="#1-5-1、C-C-编译步骤-★★★" class="headerlink" title="1.5.1、C/C++编译步骤 ★★★"></a>1.5.1、C/C++编译步骤 ★★★</h4><p><strong>(1)、c语言：以.h   .c 分别为头文件和源文件</strong></p><p>4个步骤： hello.c<br>预处理：（展开头文件里面的宏和结构体等）gcc  -E hello.c -o hello.i<br>编译：（检查语法错误，及删除预处理后文件内多余的文件）gcc  -S hello.i  -o hello.s<br>汇编：（转化为二进制文件）gcc  -c hello.s  -o hello.o<br>链接：（生成可执行程序）gcc  hello.o  -o  hello</p><p><strong>(2)、c++: 以GNU平台：.cpp 为后缀。 头文件无后缀</strong></p><p>4个步骤： hello.cpp<br>预处理:  g++  -E hello.cpp -o hello.i<br>编译：   g++  -S hello.i  -o hello.s<br>汇编：   g++  -c hello.s  -o hello.o<br>链接：   g++     hello.o  -o  hello</p><h4 id="1-5-2、C-程序的基本结构"><a href="#1-5-2、C-程序的基本结构" class="headerlink" title="1.5.2、C++程序的基本结构"></a>1.5.2、C++程序的基本结构</h4><h4 id="1-5-3、源文件的扩展名"><a href="#1-5-3、源文件的扩展名" class="headerlink" title="1.5.3、源文件的扩展名"></a>1.5.3、源文件的扩展名</h4><h4 id="1-5-4、引用头文件命名"><a href="#1-5-4、引用头文件命名" class="headerlink" title="1.5.4、引用头文件命名"></a>1.5.4、引用头文件命名</h4><h3 id="1-6、C-和-C-兼容及差异"><a href="#1-6、C-和-C-兼容及差异" class="headerlink" title="1.6、C 和 C++兼容及差异"></a>1.6、C 和 C++兼容及差异</h3><h4 id="1-6-1、C-对C的“增强”，主要表现在两个方面"><a href="#1-6-1、C-对C的“增强”，主要表现在两个方面" class="headerlink" title="1.6.1、C++对C的“增强”，主要表现在两个方面"></a>1.6.1、C++对C的“增强”，主要表现在两个方面</h4><p>在原来面向过程的机制基础上,对C语言的功能做了不少扩充。<br>增加了面向对象的机制。</p><h4 id="1-6-2、常变量"><a href="#1-6-2、常变量" class="headerlink" title="1.6.2、常变量"></a>1.6.2、常变量</h4><p>在变量基础上加const 限定：存储单元值不允许被修改。该变量称之为 只读变量（read-only-variable）;</p><h4 id="1-6-3、强制类型转换"><a href="#1-6-3、强制类型转换" class="headerlink" title="1.6.3、强制类型转换"></a>1.6.3、强制类型转换</h4><p><strong>(1)、c语言里面转换一般形式：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">（类型名）（表达式）eg：int i;char ch;ch  = (char)i;  //将i 强制转换为char 类型 struct sockaddr_in saddr;(struct sockaddr *)&saddr; //强转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2)、c++一般转换形式：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">类型名 （表达式）int i;char ch;ch  = char（i）;  //将i 强制转换为char 类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-4、变量引用-reference"><a href="#1-6-4、变量引用-reference" class="headerlink" title="1.6.4、变量引用 reference"></a>1.6.4、变量引用 reference</h4><p>对一个数据可以使用“引用”,这是C++对C的一个重要扩充,引用是一种新的变量类型,它的作用是为一个变量起一个别名。<br>不能同时引用两个变量。<br>C中函数之间的参数传递方式有:复制传递方式、地址传递方式:C++增加了函数参数引用。</p><h4 id="1-6-5、内联函数"><a href="#1-6-5、内联函数" class="headerlink" title="1.6.5、内联函数"></a>1.6.5、内联函数</h4><p>可以在内部定义成员函数,也是内联函数。</p><p>优点：提升代码运行效率；缺点：目标程序体积较大。</p><p>注意：<br>1、频繁使用的函数<br>2、函数代码语句很少（&lt;= 5局）<br>3、函数代码语句简单，没有控制语句（循环语句，switch）</p><h4 id="1-6-6、内联函数语法"><a href="#1-6-6、内联函数语法" class="headerlink" title="1.6.6、内联函数语法"></a>1.6.6、内联函数语法</h4><p>inline存储类型数据类型函数名(参数列表)</p><h4 id="1-6-7、内联函数的限制"><a href="#1-6-7、内联函数的限制" class="headerlink" title="1.6.7、内联函数的限制"></a>1.6.7、内联函数的限制</h4><p>使用内联函数可以节省运行时间,但却增加了目标程序的长度。</p><h4 id="1-6-8、函数重载"><a href="#1-6-8、函数重载" class="headerlink" title="1.6.8、函数重载"></a>1.6.8、函数重载</h4><p>即对一个函数名重新赋予它新的含义,使一个函数名可以多用。</p><h4 id="1-6-9、函数模板"><a href="#1-6-9、函数模板" class="headerlink" title="1.6.9、函数模板"></a>1.6.9、函数模板</h4><p>c++中的函数重载，函数名相同，但参数列表必须不同(1)、参数个数不同<br>(2)、参数个数相同、类型不同<br>使用的时候看实参来调用，函数的返回值不可以作为函数重载的条件</p><p>所谓函数模板,实际上是建立一个通用函数,其函数类型和形参类型不具体指定,用一个虚拟的类型来代表。</p><h4 id="1-6-10、函数默认参数"><a href="#1-6-10、函数默认参数" class="headerlink" title="1.6.10、函数默认参数"></a>1.6.10、函数默认参数</h4><p>即在调用该函数时,可以不写某些参数的值,编译器会自动把默认值传递给调用语句中。<br>默认值只能在声明中设置。</p><h3 id="1-7、再谈结构体"><a href="#1-7、再谈结构体" class="headerlink" title="1.7、再谈结构体"></a>1.7、再谈结构体</h3><p>C++ 语法中相对C语语法增加了访问杈限的概念，<br>有三种: public、prⅳate及protected，默认是 public。</p><p>public：公共成员,表示可以通过结构体变量对象直接访问到成员<br>private：私有成员，表示仅结构体成员函数可以使用的成员<br>protected：保护成员，表示被继承的派生对象可以访闷使用的成员</p><h2 id="二、内存模型及名字空间"><a href="#二、内存模型及名字空间" class="headerlink" title="二、内存模型及名字空间"></a>二、内存模型及名字空间</h2><h3 id="2-1、作用域"><a href="#2-1、作用域" class="headerlink" title="2.1、作用域"></a>2.1、作用域</h3><h4 id="2-1-1、作用域"><a href="#2-1-1、作用域" class="headerlink" title="2.1.1、作用域"></a>2.1.1、作用域</h4><p>作用域( scope)描述了一个名字在文件(编译单元)的多大范围内可见。</p><h4 id="2-1-2、C-支持三种形式的域"><a href="#2-1-2、C-支持三种形式的域" class="headerlink" title="2.1.2、C++支持三种形式的域"></a>2.1.2、C++支持三种形式的域</h4><p><strong>(1)、局部域 (local scope)</strong></p><p>局部域是包含在函数定义或者函数块中的程序文本部分。</p><p><strong>(2)、名字空间域 (namespace scope)</strong></p><p>局部域是包含在函数定义或者函数块中的程序文本部分。</p><p><strong>(3)、类域 (class scope)</strong></p><p>局部域是包含在函数定义或者函数块中的程序文本部分。</p><h4 id="2-1-2、变量的作用域"><a href="#2-1-2、变量的作用域" class="headerlink" title="2.1.2、变量的作用域"></a>2.1.2、变量的作用域</h4><p>局部变量的作用域为局部,仅能在代码块内可见。</p><h4 id="2-1-3、函数的作用域"><a href="#2-1-3、函数的作用域" class="headerlink" title="2.1.3、函数的作用域"></a>2.1.3、函数的作用域</h4><p>可以是整个类,也可以是整个名字空间,但不能是局部的。</p><h3 id="2-2、链接性及存储性"><a href="#2-2、链接性及存储性" class="headerlink" title="2.2、链接性及存储性"></a>2.2、链接性及存储性</h3><h4 id="2-2-1、链接性-linkage-描述了名称如何在各个单元中的共享。"><a href="#2-2-1、链接性-linkage-描述了名称如何在各个单元中的共享。" class="headerlink" title="2.2.1、链接性 (linkage)描述了名称如何在各个单元中的共享。"></a>2.2.1、链接性 (linkage)描述了名称如何在各个单元中的共享。</h4><h4 id="2-2-2、外部链接：是指名称可以在文件间共享。"><a href="#2-2-2、外部链接：是指名称可以在文件间共享。" class="headerlink" title="2.2.2、外部链接：是指名称可以在文件间共享。"></a>2.2.2、外部链接：是指名称可以在文件间共享。</h4><h4 id="2-2-3、内部链接：名称仅仅能在一个文件中的函数共享。"><a href="#2-2-3、内部链接：名称仅仅能在一个文件中的函数共享。" class="headerlink" title="2.2.3、内部链接：名称仅仅能在一个文件中的函数共享。"></a>2.2.3、内部链接：名称仅仅能在一个文件中的函数共享。</h4><h4 id="2-2-4、变量链接及存储性"><a href="#2-2-4、变量链接及存储性" class="headerlink" title="2.2.4、变量链接及存储性"></a>2.2.4、变量链接及存储性</h4><h4 id="2-2-5、变量的说明限定符：auto-register-static-extern"><a href="#2-2-5、变量的说明限定符：auto-register-static-extern" class="headerlink" title="2.2.5、变量的说明限定符：auto register static  extern"></a>2.2.5、变量的说明限定符：auto register static  extern</h4><h4 id="2-2-6、函数的链接性及存储性：函数的存储持续性为静态的。"><a href="#2-2-6、函数的链接性及存储性：函数的存储持续性为静态的。" class="headerlink" title="2.2.6、函数的链接性及存储性：函数的存储持续性为静态的。"></a>2.2.6、函数的链接性及存储性：函数的存储持续性为静态的。</h4><p>存储方式：4种： auto register static  extern</p><h4 id="2-2-7、语言链接性："><a href="#2-2-7、语言链接性：" class="headerlink" title="2.2.7、语言链接性："></a>2.2.7、语言链接性：</h4><p>对于函数或变量而言,只要有链接性,则每种编程语言,都有自己的规则来处理它们的名字。这个就是语言的链接性</p><h3 id="2-3、动态内存"><a href="#2-3、动态内存" class="headerlink" title="2.3、动态内存"></a>2.3、动态内存</h3><h3 id="2-4、声明区与作用域"><a href="#2-4、声明区与作用域" class="headerlink" title="2.4、声明区与作用域"></a>2.4、声明区与作用域</h3><p>C++标准的名字空间属性<br>声明区：可以进行声明的区域<br>潜在的作用域：变量潜在的作用域,从声明点,到声明区结尾</p><h3 id="2-5、名字空间"><a href="#2-5、名字空间" class="headerlink" title="2.5、名字空间"></a>2.5、名字空间</h3><h2 id="三、输入输出流"><a href="#三、输入输出流" class="headerlink" title="三、输入输出流"></a>三、输入输出流</h2><h3 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h3><p>C++的输出和输入是用“流”(stream)的方式实现的。<br>在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据。<br>在执行输入输出语句时，先把数据顺序存放在输出缓冲区中，直到输出缓冲区满或遇到输入输出语句中的endl(或′＼n′，ends，flush)为止，此时将缓冲区中已有的数据一起输出，并清空缓冲区。</p><h3 id="3-2、C-输出"><a href="#3-2、C-输出" class="headerlink" title="3.2、C++输出"></a>3.2、C++输出</h3><p>输出流即从程序中输出一系列的字符串,使用cout对象</p><h3 id="3-3、C-输入"><a href="#3-3、C-输入" class="headerlink" title="3.3、C++输入"></a>3.3、C++输入</h3><p>输入流即向程序输入一系列的字符串,使用cin对象</p><h3 id="3-4、格式控制符"><a href="#3-4、格式控制符" class="headerlink" title="3.4、格式控制符"></a>3.4、格式控制符</h3><h2 id="四、类和对象"><a href="#四、类和对象" class="headerlink" title="四、类和对象"></a>四、类和对象</h2><h3 id="4-1、OPP思想"><a href="#4-1、OPP思想" class="headerlink" title="4.1、OPP思想"></a>4.1、OPP思想</h3><h4 id="4-1-1、抽象"><a href="#4-1-1、抽象" class="headerlink" title="4.1.1、抽象"></a>4.1.1、抽象</h4><p>抽象就是声明定义一个类，抽象概括一类对象的公共性质。</p><p><strong>数据抽象</strong>：设置成员变量</p><p><strong>代码抽象</strong>：设置成员函数</p><p><strong>抽象的实现</strong>：通过类的定义</p><h4 id="4-1-2、封装"><a href="#4-1-2、封装" class="headerlink" title="4.1.2、封装"></a>4.1.2、封装</h4><p>封装将数据成员和成员函数结合在一起，形成一个整体，就是类体部分。</p><h4 id="4-1-3、分类"><a href="#4-1-3、分类" class="headerlink" title="4.1.3、分类"></a>4.1.3、分类</h4><p>层层分类，使概念逐渐细化、具体化。</p><h4 id="4-1-4、继承"><a href="#4-1-4、继承" class="headerlink" title="4.1.4、继承"></a>4.1.4、继承</h4><p>子类继承父类所有的属性、方法，并可定义自己的特有属性与方法。</p><h4 id="4-1-5、多态"><a href="#4-1-5、多态" class="headerlink" title="4.1.5、多态"></a>4.1.5、多态</h4><p>多态性是面向对象程序设计的一个重要特征，能增加程序的灵活性。</p><h3 id="4-2、类的声明定义"><a href="#4-2、类的声明定义" class="headerlink" title="4.2、类的声明定义"></a>4.2、类的声明定义</h3><p>C++中对象的类型称为类(class)，类代表了某一批对象的共性和特征,类是对象的抽象，而对象是类的具体实例 (instance)。</p><p>(1)、编写一个的类基本语法形式：</p><p>class 类名{</p><p>private:</p><p>​    私有的数据和成员函数;</p><p>public:</p><p>​    公有的数据和成员函数;</p><p>protected:</p><p>​    保护的数据和成员函数;<br>};</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:    int a;    int setx(int val);#if 0    int setx(int val)    {        x = val;    }#endif    int getx()    {        return x;    }    protected:    int b;private:    int c;    int x;    };int Demo::setx(int val){    x = val;    return 0;}int main(int argc, char *argv[]){    Demo obj;    obj.setx(123);    cout << obj.getx() << endl;        return 0;}//cout:123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3、构造和析构"><a href="#4-3、构造和析构" class="headerlink" title="4.3、构造和析构"></a>4.3、构造和析构</h3><h4 id="4-3-1、构造函数"><a href="#4-3-1、构造函数" class="headerlink" title="4.3.1、构造函数"></a>4.3.1、构造函数</h4><p>构造函数是一种特殊的成员函数，与其他成员函数不同。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:        //公有    Demo(int val)    //构造函数：无返回值，函数名与类名相同，可以有形参，定义对象的时候自动调用    {        myval = val;        cout << "func: " << __func__ << "line: " << __LINE__ << endl;    }        int getval()    {        return myval;    }private:    //私有    int myval;    };int main(int argc, char *argv[]){    Demo obj(123);    //构造对象并且传递参数        cout << obj.getval() << endl;        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2、析构"><a href="#4-3-2、析构" class="headerlink" title="4.3.2、析构"></a>4.3.2、析构</h4><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:        //公有    Demo(int val)    //构造函数：无返回值，函数名与类名相同，可以有形参，定义对象的时候自动调用    {        myval = val;        cout << "func: " << __func__ << "line: " << __LINE__ << endl;    }        ~Demo()            //析构函数：无参数，无返回值    {        cout << "func: " << __func__ << "line: " << __LINE__ << endl;    }        int getval()    {        return myval;    }private:    //私有    int myval;    };int main(int argc, char *argv[]){    Demo obj(123);    //构造对象并且传递参数        cout << obj.getval() << endl;        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1634787253868.png" alt="1634787253868"></p><h4 id="4-3-3、拷贝构造"><a href="#4-3-3、拷贝构造" class="headerlink" title="4.3.3、拷贝构造"></a>4.3.3、拷贝构造</h4><p>1、定义对象的一般格式</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1634795594450.png" alt="1634795594450"></p><p>2、动态创建对象</p><p>cp2</p><p>3、函数的传值调用</p><p>cp3</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1634796412720.png" alt="1634796412720"></p><h4 id="4-3-4、浅拷贝和深拷贝"><a href="#4-3-4、浅拷贝和深拷贝" class="headerlink" title="4.3.4、浅拷贝和深拷贝"></a>4.3.4、浅拷贝和深拷贝</h4><p>(1)、浅拷贝：同类型的两个对象的成员指针，指向同一个堆区空间，两成员指针相互干扰</p><p>(2)、深拷贝：同类型的两个对象的成员指针，指向两个不同的堆区，互不干扰</p><h3 id="4-4、this指针"><a href="#4-4、this指针" class="headerlink" title="4.4、this指针"></a>4.4、this指针</h3><p>this指针是一个特殊的指针，指向类对象自身的首地址。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1634800413078.png" alt="1634800413078"></p><h3 id="4-5、static成员"><a href="#4-5、static成员" class="headerlink" title="4.5、static成员"></a>4.5、static成员</h3><h3 id="4-4、const成员"><a href="#4-4、const成员" class="headerlink" title="4.4、const成员"></a>4.4、const成员</h3><h4 id="4-4-1、const成员函数"><a href="#4-4-1、const成员函数" class="headerlink" title="4.4.1、const成员函数"></a>4.4.1、const成员函数</h4><p>在类内声明语法形式<br>            &lt;数据类型&gt; &lt;函数名&gt; (&lt;参数列表&gt;) const;<br>            在类外定义语法形式<br>            &lt;数据类型&gt;  &lt;类名&gt; :: &lt;函数名&gt; (&lt;参数列表&gt;) const<br>            {<br>            ……<br>            }</p><h4 id="4-4-2、const对象"><a href="#4-4-2、const对象" class="headerlink" title="4.4.2、const对象"></a>4.4.2、const对象</h4><pre class="line-numbers language-c++"><code class="language-c++">#include <assert.h>#include <iostream>using namespace std;class Demo{public:            Demo(int a=0, int b= 0):x(a), y(b)        {        cout << "line:" << __LINE__ <<endl;    }    public:    void setx(int val)     //const    {        x = val;        //const 修饰的成员函数 不能修改成员变量    }        void sety(int val)    {        y = val;    }    int getx() const    //不能修改 可以被const对象调用    {        return x;    }    int gety()    {        return y;    }private:        int x;        int y;};int main(int argc, char *argv[]){    Demo obj(321, 123);    const Demo obj2(321, 123);    //const 修饰的对象    //obj.setx(111);            //const 修饰的对象，只能掉const成员函数    obj.sety(222);        //obj.setx(333);    cout << obj2.getx()<<endl;    cout << obj.getx()<<endl;    cout << obj.gety()<<endl;        return 0;}/*输出：    line:17    line:17    321    321    222*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4、友元"><a href="#4-4、友元" class="headerlink" title="4.4、友元"></a>4.4、友元</h3><p>类的朋友</p><h4 id="4-4-1、友元函数"><a href="#4-4-1、友元函数" class="headerlink" title="4.4.1、友元函数"></a>4.4.1、友元函数</h4><p>指：某个函数是类的友元；</p><p>一个类的函数是多个类的函数</p><h4 id="4-4-2、友元类"><a href="#4-4-2、友元类" class="headerlink" title="4.4.2、友元类"></a>4.4.2、友元类</h4><pre class="line-numbers language-c++"><code class="language-c++">#include <assert.h>#include <iostream>using namespace std;class A{public:    A(int val=0):myval(val)    {        cout<<__LINE__<<endl;    }public:    int getval()    {        return myval;    }    friend class B;    //声明类B是类A的友元private:    int myval;    };class B{public:    B(int val=0):myval(val)    {        cout<<__LINE__<<endl;    }public:    void setval(A &obj)    //这是A的友元    {        obj.myval = this->myval;    //访问A类的私有成员    }    int getval()    {        return myval;    }    private:    int myval;    };int main(int argc, char *argv[]){    A obj1(123);    B obj2(321);    obj2.setval(obj1);    //通过obj2修改obj1的成员1变量值        cout<<obj1.getval()<<endl;        return 0;}/*输出：    17    34    321*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-3、友元成员函数"><a href="#4-4-3、友元成员函数" class="headerlink" title="4.4.3、友元成员函数"></a>4.4.3、友元成员函数</h4><p>B类的成员函数可以是类A的友员</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1634890579045.png" alt="1634890579045"></p><pre class="line-numbers language-C++"><code class="language-C++">#include <iostream>using namespace std;class A;   //前向 声明class B{public:    B(int val=0) :myval(val)    {        cout<<__LINE__<<endl;    }public:    void setval(A &); //  函数的内部声明private:    int myval; //};#if 1class A{public:    A(int val=0):myval(val)    {        cout<<__LINE__<<endl;    }public:    int getval()    {        return myval;    }    friend void B::setval(A &); //声明 B类的成员方法是 类A的友元private:    int myval;};#endif void B::setval(A &obj)   //A的友元{    obj.myval = this->myval; //}int main(){    A obj(123);    B obj2(321);    obj2.setval(obj);     cout<<obj.getval()<<endl;    //cout<<ob2.getval()<<endl;    return 0;}/*输出：    22    9    321*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、运算符重载"><a href="#五、运算符重载" class="headerlink" title="五、运算符重载"></a>五、运算符重载</h2><h3 id="5-1、为什么需要重载运算符"><a href="#5-1、为什么需要重载运算符" class="headerlink" title="5.1、为什么需要重载运算符"></a>5.1、为什么需要重载运算符</h3><p>函数可以重载，运算符也可以重载。</p><p>运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p><h3 id="5-2、运算符重载简介"><a href="#5-2、运算符重载简介" class="headerlink" title="5.2、运算符重载简介"></a>5.2、运算符重载简介</h3><h4 id="5-2-1、语法形式"><a href="#5-2-1、语法形式" class="headerlink" title="5.2.1、语法形式"></a>5.2.1、语法形式</h4><p>运算符重载的一般语法如下：</p><pre class="line-numbers language-c++"><code class="language-c++"><返回类型说明符> operator <运算符符号>(<参数表>){    <函数体>}                          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-2、可以被重载的运算符"><a href="#5-2-2、可以被重载的运算符" class="headerlink" title="5.2.2、可以被重载的运算符"></a>5.2.2、可以被重载的运算符</h4><pre class="line-numbers language-c++"><code class="language-c++">算术运算符：+、-、*、/、%、++、--位操作运算符：&、|、~、^(位异或)、<<(左移)、>>(右移)逻辑运算符：!、&&、||比较运算符：<、>、>=、<=、==、!=赋值运算符：=、+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=其他运算符：[]、()、->、,、new、delete、new[]、delete[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-3、不被重载的运算符"><a href="#5-2-3、不被重载的运算符" class="headerlink" title="5.2.3、不被重载的运算符"></a>5.2.3、不被重载的运算符</h4><p>==不能被重载的运算符，其余的都可以被重载==</p><pre class="line-numbers language-c++"><code class="language-c++">逗号“.”、?号表达式“? :”、sizeof、作用域“::”、指针运算符“*”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;int main(){    string a = "hello";    string b = "world";    cout << a+b << endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3、友元运算符重载"><a href="#5-3、友元运算符重载" class="headerlink" title="5.3、友元运算符重载"></a>5.3、友元运算符重载</h3><h4 id="5-3-1、含义"><a href="#5-3-1、含义" class="headerlink" title="5.3.1、含义"></a>5.3.1、含义</h4><p>指：运算符重载作为类的友元</p><h4 id="5-3-2、语法形式"><a href="#5-3-2、语法形式" class="headerlink" title="5.3.2、语法形式"></a>5.3.2、语法形式</h4><p>友元运算符重载的语法形式：</p><pre class="line-numbers language-c++"><code class="language-c++">class 类名{    friend 返回类型 operator 运算符(形参表);}类外定义格式:返回类型 operator 运算符(参数表){    函数体;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-3、四则运算符运算"><a href="#5-3-3、四则运算符运算" class="headerlink" title="5.3.3、四则运算符运算"></a>5.3.3、四则运算符运算</h4><pre class="line-numbers language-c++"><code class="language-c++">/*四则运算符运算*/#include <iostream>using namespace std;class Demo{public:        Demo(int val):myval(val)    {        cout<<__LINE__<<endl;    }    public:        int getval()const    {        return this->myval;    }        friend Demo operator + (Demo &obj1, Demo &obj2);    friend Demo operator - (Demo &obj1, Demo &obj2);    friend Demo operator * (Demo &obj1, Demo &obj2);    friend Demo operator / (Demo &obj1, Demo &obj2);    private:    int myval;};//重载运算符 '+'//'+' 是双目运算符，需要两个参数Demo operator + (Demo &obj1, Demo &obj2){    Demo obj3(obj1.myval + obj2.myval);    //运算obj1和obj2的和然后再通过构造函数    return obj3;}Demo operator - (Demo &obj1, Demo &obj2){    Demo obj3(obj1.myval - obj2.myval);    //运算obj1和obj2的和然后再通过构造函数    return obj3;}Demo operator * (Demo &obj1, Demo &obj2){    Demo obj3(obj1.myval * obj2.myval);    //运算obj1和obj2的和然后再通过构造函数    return obj3;}Demo operator / (Demo &obj1, Demo &obj2){    Demo obj3(obj1.myval / obj2.myval);    //运算obj1和obj2的和然后再通过构造函数    return obj3;}int main(int argc, char *argv[]){    Demo a(8);    Demo b(2);    Demo c = operator + (a, b);    //Demo c = a+b;    Demo d = operator - (a, b);    //Demo d = a-b;    Demo e = operator * (a, b);    //Demo d = a*b;    Demo f = operator / (a, b);    //Demo d = a/b;        cout << a.getval() << endl;    cout << b.getval() << endl;    cout << "a + b: " << c.getval() << endl;    cout << "a - b: " << d.getval() << endl;    cout << "a * b: " << e.getval() << endl;    cout << "a / b: " << f.getval() << endl;        return 0;}/*cout：15151515151582a + b: 10a - b: 6a * b: 16a / b: 4*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-4、”-”运算符"><a href="#5-3-4、”-”运算符" class="headerlink" title="5.3.4、”++”运算符"></a>5.3.4、”++”运算符</h4><pre class="line-numbers language-c++"><code class="language-c++">/*前++与后++的实现*/#include <iostream>using namespace std;class Demo{public:    Demo (int x) :myval(x){ cout << __LINE__<<endl; }public:    int getval()const    {        return this->myval;    }    friend Demo operator ++( Demo &obj, int  );  //后 ++  int 作为 占位符     friend Demo operator ++(  Demo &obj );private:    int myval;};//重载运算符 "++"// ++ 单目运算符  需要指定一个参数#if 1Demo operator ++( Demo &obj, int val )  //后++{    Demo obj2(obj.myval++);    return obj2; }#endif #if 1Demo operator ++(Demo &obj )  //前 ++ {    Demo obj2(++obj.myval);    return obj2; }#endif int main(){    Demo a(222);    Demo b(444);  /*       a++; //等价 operator ++ (a);    Demo c = a++;*/    Demo c = ++a;     cout << a.getval()<<endl;    cout << b.getval()<<endl;    cout << c.getval()<<endl;   // cout << a.getval()<<endl;    return 0;}/*cout：666223444223*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-5、”-”运算符"><a href="#5-3-5、”-”运算符" class="headerlink" title="5.3.5、”!”运算符"></a>5.3.5、”!”运算符</h4><pre class="line-numbers language-c++"><code class="language-c++">/*!运算*/#include <iostream>using namespace std;class Demo{public:    Demo (bool flag = true){         this->flag = flag;        cout << __LINE__<<endl;     }public:    friend bool  operator !( Demo &obj );  private:    bool flag;};//重载运算符 "!"// ! 单目运算符  需要指定一个参数#if 1bool  operator !( Demo &obj )  {    return !obj.flag; }#endif int main(){    Demo a(true);    Demo b(false);     if(!a)    {        cout <<"a is false"<<endl;     }else     {                cout <<"a is true"<<endl;     }    return 0;}/*cout：88a is true*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4、成员函数运算符重载"><a href="#5-4、成员函数运算符重载" class="headerlink" title="5.4、成员函数运算符重载"></a>5.4、成员函数运算符重载</h3><p>第一个参数类型和对象类型匹配，可以使用this 指针，那么形参个数可以 减 1。</p><h4 id="5-4-1、语法形式"><a href="#5-4-1、语法形式" class="headerlink" title="5.4.1、语法形式"></a>5.4.1、语法形式</h4><p>成员函数运算符重载的语法形式：</p><pre class="line-numbers language-c++"><code class="language-c++">class 类名{    返回类型 operator 运算符(形参表);}类外定义格式:返回类型:: operator 运算符(形参表){    函数体;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2、”-”运算符"><a href="#5-4-2、”-”运算符" class="headerlink" title="5.4.2、”+=”运算符"></a>5.4.2、”+=”运算符</h4><pre class="line-numbers language-c++"><code class="language-c++">/*+=运算*/#include <iostream>using namespace std;class Demo{public:    Demo(int x):myval(x)    {        cout <<__LINE__<<endl;    }public:    int getval()const ;         Demo & operator +=(Demo &obj); //声明运算符重载 +=private:    int myval;};int Demo:: getval() const{    return this->myval;}//重载运算符  +=//+=：双目运算符，由于该重载函数是类的成员，则之需要传一个参数即可，//另一个参数可以用this直接访问//a+=b; 返回aDemo & Demo::operator +=(Demo &obj)  //内部成员函数实现重载  有this 指针， 可以用this ，传参是可以少一个{    this->myval += obj.myval;    return (*this); //返回this 指针指向的对象}int main(){    Demo a(222);    Demo b(444);    a += b;  //等价 a.operator +=(b);   //a = a + b    cout <<a.getval()<<endl;    cout <<b.getval()<<endl;    return 0;}/*cout：88666444*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2、友元成员函数"><a href="#5-4-2、友元成员函数" class="headerlink" title="5.4.2、友元成员函数"></a>5.4.2、友元成员函数</h4><p>(1)、用友元重载+实现对象与整型数相加 Demo b(5):</p><p>b+3;</p><p>(2)、成员函数重载实现b+3。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:    Demo(int x):myval(x)    {        cout <<__LINE__<<endl;    }public:    int getval()const ;         int operator + (int ); //声明运算符重载 +   // friend int operator + (Demo &obj, int val); private:    int myval;};int Demo:: getval() const{    return this->myval;}#if 1/*内部成员函数实现运算符重载  有this 指针 ，传参是可以少一个**行参个数 = 运算符操作个数 - 1*/int Demo::operator + (int val){    return this->myval + val;  //返回this 指针指向的对象}#endif /*友元运算符重载：因为友元函数没有this 指针， 所以对应的重载运算符 需要多少个操作数 那则传递多少个 参数 * * */#if 0int operator + (Demo &obj, int val)  // 参是可以少一个{    return obj.myval + val;  //返回this 指针指向的对象}#endif int main(){    Demo a(222);    Demo b(444);   // cout << 3 + b << endl;   //（b, 3）;    cout << b + 3 << endl;   //（b, 3）;    return 0;}/*友元运算符重载和成员运算符重载 函数选择： * 1、如果成员函数的this 指针指向运算符的第一操作数的类型， 与当前对象类型匹配才可以用  this 指针 * 2、否则就使用友元运算符重载 * *//*cout：88447*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2、左移、输出"><a href="#5-4-2、左移、输出" class="headerlink" title="5.4.2、左移、输出"></a>5.4.2、左移、输出</h4><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:    Demo (int x):myval(x) { cout << __LINE__<<endl; }public:    int getval() const;    Demo operator << (int bits); //声明运算符重载  <<    friend  ostream & operator << (ostream &, Demo &);private:    int myval; };/**********************************************/    int Demo:: getval()const{    return this->myval;}Demo Demo::operator << (int bits) //运算符重载  <<  ：左移 运算  {#if 0    Demo tmp(this->myval << bits);    return tmp;#endif     return Demo (this->myval << bits);}ostream & operator << (ostream & out, Demo &obj ){    out <<" ______________" <<endl;    out << obj.myval << endl;    //return out;}int main(){    Demo a(1);     Demo b(2);#if 0        Demo tmp  = a << 2 ;        cout << a.getval()<<endl;        cout << tmp.getval() + 1<<endl;#endif    cout << a << b <<endl;   // a + b; //    return 0;}/*cout:66 ______________1 ______________2*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2、”-”括号””运算符；成员"><a href="#5-4-2、”-”括号””运算符；成员" class="headerlink" title="5.4.2、”()”括号””运算符；成员"></a>5.4.2、”()”括号””运算符；成员</h4><p>==特殊：”()”不能是友元，必须是成员==</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:    Demo (int x) :myval(x)    {     //cout << __LINE__<<endl;    }public:   // friend  int operator + ( Demo &, int a) ;    int operator + ( int a)    {        return this->myval + a;    }#if 1#if 1    int operator () (int a)    {        return myval + a;    }#else    int  operator () (int a, int b)    {        return  a + b;    }#endif #endif      // friend  int operator ()(Demo &obj, int a);  // error : ()只能是成员， 不能是友元    private:    int myval;};/*int operator ()(Demo &obj, int a){    return obj.myval + a;}*/int main(){    Demo a(5);  //初始化   /*     cout << a + 3 << endl; //cout <<a.operator+(3)  << endl;    cout << (a + 3) << endl; //cout << operator (a + 3) <<endl;*/    #if 0    cout << a(6) << endl;    cout << a( 9 + 3 ) << endl;#endif         return 0;}/*cout:*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5、运算符重载注意事项"><a href="#5-5、运算符重载注意事项" class="headerlink" title="5.5、运算符重载注意事项"></a>5.5、运算符重载注意事项</h3><pre class="line-numbers language-c++"><code class="language-c++">A、除关系运算符"."、成员指针运算符".*"、作用域运算符"::"、sizeof运算符和三目运算符"?:"以外，C++中的所有运算符都可以重载（其中“=”和“&”不必用户重载）。B、重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。C、运算符重载的实质是函数重载，遵循函数重载的选择原则。D、重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。E、运算符重载不能改变该运算符用于内部类型对象的含义。F、运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。G、重载运算符的函数不能有默认的参数，否则就改变了运算符的参数个数。H、重载的运算符只能是用户自定义类型，否则就不是重载而是改变了现有的C++标准数据类型的运算符的规则。I、运算符重载可以通过成员函数的形式，也可是通过友元函数，非成员非友元的普通函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、模板"><a href="#六、模板" class="headerlink" title="六、模板"></a>六、模板</h2><h3 id="6-1、什么是模板"><a href="#6-1、什么是模板" class="headerlink" title="6.1、什么是模板"></a>6.1、什么是模板</h3><h4 id="6-2-1、模板简介"><a href="#6-2-1、模板简介" class="headerlink" title="6.2.1、模板简介"></a>6.2.1、模板简介</h4><p>C++中模板是支持参数化多态的工具，就是让类或者函数声明为一种通用类型，使得类中的某些数据成员或者成员函数的参数、返回值在实际使用时可以是任意类型。</p><p>使用模板的目的就是能够让程序员编写与类型无关的代码,模板也是泛型编程的基。</p><h4 id="6-2-2、模板通常两种形式"><a href="#6-2-2、模板通常两种形式" class="headerlink" title="6.2.2、模板通常两种形式"></a>6.2.2、模板通常两种形式</h4><p>模板是一种对类型进行参数化的工具，通常有两种形式：</p><p><strong>函数模板：</strong><br>    函数模板针对仅参数类型不同的函数<br><strong>类模板：</strong><br>    类模板针对仅数据成员和成员函数类型不同的类</p><h4 id="6-1-3、函数模板"><a href="#6-1-3、函数模板" class="headerlink" title="6.1.3、函数模板"></a>6.1.3、函数模板</h4><pre class="line-numbers language-c++"><code class="language-c++">仅针对函数参数类型，返回值不同，功能相同的函数template < class形参名, class形参名> 返回类型 函数名(参数列表){    函数体}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;//声明及定义 类型模板函数template <typename T>    //typename 可以class 代替T add(T a, T b){    return (a + b);}int main(int argc, char *argv[]){    double e = add(1.2, 3.4);        //根据返回值 类型自动匹配 T 为 double    cout << "e: " << e << endl;    int sum = add(5, 6);            //根据返回值 类型自动匹配 T 为 int    cout << "sum: " << sum << endl;        //cout << add(10, 1.1) << endl;    //error：自动匹配的时候 没有匹配到 10的int和1.1的double    //因为没有定义两个类型的函数模板        cout << "add: " << add<double>(10, 1.1) << endl;    //添加 add<double> 即可解决    return 0;}/*cout:e: 4.6sum: 11add: 11.1*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:    Demo (int x):myval(x)    {        cout << __LINE__ << endl;    }    ~Demo()    {        cout << __LINE__ << endl;    }public:    int getval()const    {        return this->myval;    }    Demo operator + (Demo &obj)        //成员运算符重载    {        cout << "++++" << endl;        return Demo(this->myval + obj.myval);    }private:    int myval;};/*模板说明： *template <class T> *        template 模板说明关键字 *        class 和 typename 一样 类型说明关键字 *        T : 模板行参 用来替代 数据类型 */    //声明及定义 类型模板函数 必须使用 template 说明template <typename T>    //typename 可以用class代替T add(T &a, T &b){    return (a + b);}int main(int argc, char *argv[]){    Demo a(222);    Demo b(444);        Demo c = add<Demo>(a, b);        cout << c.getval() << endl;        return 0;}/*cout:1515++++15666191919*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;//template <class T> T add(T , T);  //函数模版声明#if 0template <typename B>  //函数模版的定义B add( B x, B y ){    return x + y;}#else template <class T1, class T2, class T3>T1 add( T2 x, T3 y ){    return x + y;}#endif int main(){    #if 0    cout << add(1, 3) <<endl;    cout << add(1.1, 3.1) <<endl;    cout << add< >(2,3) << endl; //函数模版调用，自动匹配数据类型    cout << add< >(2.1,3.1) << endl; //函数模版调用，自动匹配数据类型    cout << add< double >(2,3) << endl; //函数模版调用显式转换为double     cout << add< double >(4, 3.1) << endl; //函数模版调用, 显示指定返回值类型为 double     cout << add< >(2,3) << endl; //函数模版调用，自动匹配数据类型#endif     cout << add< int>(2,3) << endl; //函数模版调用，显示指定返回值类型为 int     cout << add< double>(2,3) << endl; //函数模版调用，需要显示指定 返回值类型 double     cout << add< double >(1, 3.1) <<endl;    cout << add< double , double, int  >(2.7 , 3.3) << endl; //函数模版调用， 第一个类型匹配万为 返回值类型，后两个为参数类型， 如果参数类型不匹配，会发生强转后再计算 然后返回指定的 返回值类型     return 0;}/*cout:554.15.7*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-1-4、类模板"><a href="#6-1-4、类模板" class="headerlink" title="6.1.4、类模板"></a>6.1.4、类模板</h4><pre class="line-numbers language-c++"><code class="language-c++">类模板针对仅数据成员和成员函数类型不同的template < class形参名, class形参名，…> class 类名{    …}template <class T, typename B …>template： 关键字，说明是一个模板class T ： 定义类型模板形参，class 等价于 typenameT ： 类型模板形参，用来替换数据类型注意：模板声明和全局只能在全局。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2、类型模板参数"><a href="#6-2、类型模板参数" class="headerlink" title="6.2、类型模板参数"></a>6.2、类型模板参数</h3><p>指类中成员方法返回值类型 参数类型 及 成员变量类型为通用类型 </p><p>语法形式：</p><pre class="line-numbers language-c++"><code class="language-c++">template <typename T, ...., typename C>class 类名{    public:    T 方法名(T 参数名)    {        语句块；    }    private：        T 成员变量名；}；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;//定义 类模版template <typename T>  //声明类型模版 Ｔ class Demo{public:    Demo( T  val){         myval = val;    }  //由于 Ｔ 是通用 类型，所以 构造函数不能指定默认参数值    ~Demo(){};public:   void  setval (T val);    T getval() const;private:    T myval;};//类外部成员方法实现template <typename T>  //声明类型模版 Ｔ void Demo<T> ::setval( T val ) {    myval = val;}template <typename T>  //声明类型模版 Ｔ T Demo<T>::getval()const{    return myval;}int main(){    Demo <int> obj(123);   // Demo <> obj(222);    obj.setval(666);    cout << obj.getval() <<endl;      return 0;}/*cout:666*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<br>1&gt; 模板形参表示的是一个未知的类型。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同，即可以用于指定返回类型，变量声明等。<br>2&gt; 类型形参仅由关键字class或typename后接说明符构成<br>3&gt; 譬如函数模板</p><pre class="line-numbers language-c++"><code class="language-c++">template<class T>  T func(T var){    …}template< typename T>  T func(T var){    …}其中T就是一个类型形参    形参var及返回值类型为T，实际类型在实例化时确定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3、非类型模板参数"><a href="#6-3、非类型模板参数" class="headerlink" title="6.3、非类型模板参数"></a>6.3、非类型模板参数</h3><p>模板的非类型形参就是内置类型形参<br>譬如：</p><pre class="line-numbers language-c++"><code class="language-c++">template<class T, int var> class Demo{    …};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中int var就是非类型的模板形参。<br>非类型形参在模板定义的内部是常量值。<br>非类型模板的形参只能是整型、指针和引用，像double，String, String **这样的类型是不允许的。但是double &amp;，double *，对象的引用或指针是正确的。非类型模板形参的实参如果是表达式，则必须是一个常量表达式，在编译时计算出结果。<br>非类型模板形参和实参间允许类型转换。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <assert.h>using namespace std;//非类型模版参数template <typename T, int len>  //int len  是非类型行参，指定数组元素个数class Array{public:    Array(T val);     ~Array();public:    void setval(const int pos, const T val); //设置对应下标的元素    T getval( const int pos ) const;  //获取对应下标的元素值private:    T *buffer;  //保存数组首地址};template <typename T, int  len>Array<T,len>::Array(T val)    //构造函数实现{    cout << __func__<< "line:"<<__LINE__<<endl;    buffer = new T [len];    assert(NULL != buffer);    for(int i=0; i<len; i++)    {        buffer[i] = val;    }}template <typename T, int  len>Array<T, len>::~Array()  //析构函数的实现{        cout << __func__<< "line:"<<__LINE__<<endl;    delete []buffer;     buffer = NULL; }template <typename T, int  len>void Array<T,len>::setval(const int pos, const T val)  //设置对应下标的元素值{    buffer[pos] = val; }template <typename T, int  len>T Array<T, len> ::getval(const int pos) const //获取对应下标的元素值{    return buffer[pos]; }int main(){    Array<int, 10> obj(0);    for(int i=0; i<10 ;i++)    {        obj.setval(i, i+1);    }    for(int i=0; i<10 ; i++)    {        cout<<obj.getval(i) <<endl;     }    return 0;}/*cout:12345678910~Arrayline:33*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4、默认模板参数"><a href="#6-4、默认模板参数" class="headerlink" title="6.4、默认模板参数"></a>6.4、默认模板参数</h3><p>类模板的类型形参可以有默认值，函数模板的类型形参则不能。<br>函数模板和类模板都可以为模板的非类型形参提供默认值。<br>类模板的类型形参默认值形式为：</p><pre class="line-numbers language-c++"><code class="language-c++">template<class T1, class T2=int> class Demo{    …};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类型形参T1、T2，其中T2的默认类型为int。<br>类模板类型形参默认值和函数的默认参数一样，如果有多个类型形参则从左起的莫个形参设定了默认值之后，右边所有模板形参都要设定默认值<br>和函数默认参数一样，如果在类模板的外部定义类中的成员时，模板形参表应省略默认的形参类型。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <assert.h>using namespace std;//默认类型参数模版//template <typename T, int len>                //int len  是非类型行参，指定数组元素个数template <typename T = int , int len=10>        //指定默认参数class Array{public:    Array(T val);     ~Array();public:    void setval(const int pos, const T val);    //设置对应下标的元素    T getval( const int pos ) const;            //获取对应下标的元素值private:    T *buffer;                                  //保存数组首地址};template <typename T, int  len>Array<T,len>::Array(T val)                       //构造函数实现{    cout << __func__<< "line:"<<__LINE__<<endl;    buffer = new T [len];    assert(NULL != buffer);    for(int i=0; i<len; i++)    {        buffer[i] = val;    }}template <typename T, int  len>Array<T, len>::~Array()                         //析构函数的实现{        cout << __func__<< "line:"<<__LINE__<<endl;    delete []buffer;     buffer = NULL; }template <typename T, int  len>void Array<T,len>::setval(const int pos, const T val)  //设置对应下标的元素值{    buffer[pos] = val; }template <typename T, int  len>T Array<T, len> ::getval(const int pos) const   //获取对应下标的元素值{    return buffer[pos]; }int main(){    //Array<int, 10> obj(0);    Array<  > obj(0); // 指定默认参数，可以具体参数    for(int i=0; i<10 ;i++)    {        obj.setval(i, i+1);    }    for(int i=0; i<10 ; i++)    {        cout<<obj.getval(i) <<endl;     }    return 0;}/*cout:12345678910~Arrayline:35*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5、友元函数模板"><a href="#6-5、友元函数模板" class="headerlink" title="6.5、友元函数模板"></a>6.5、友元函数模板</h3><p>如果一个类是模板类，又要实现运算符重载，一般的，运算符重载是友员函数，那么显然会涉及到一个问题，一个友员如何操作模板类。<br>其实质就是类模板和函数模板的综合应用。</p><pre class="line-numbers language-javascript"><code class="language-javascript">#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>#include <span class="token operator">&lt;</span>assert<span class="token punctuation">.</span>h<span class="token operator">></span>using namespace std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*友元模板*/</span>template <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">//类 模板</span><span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token punctuation">:</span>    <span class="token function">Demo</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token number">0</span>    friend T operator <span class="token operator">+</span> <span class="token punctuation">(</span>Demo <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>obj1<span class="token punctuation">,</span> Demo <span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>obj2<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> obj1<span class="token punctuation">.</span>x <span class="token operator">+</span> obj2<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#<span class="token keyword">else</span>    template <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">></span>    friend B operator <span class="token operator">+</span> <span class="token punctuation">(</span>Demo <span class="token operator">&lt;</span>B<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">,</span> Demo <span class="token operator">&lt;</span>B<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token keyword">private</span><span class="token punctuation">:</span>    T x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>template <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">></span>Demo <span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">Demo</span><span class="token punctuation">(</span>B x<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>template <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">//函数模板 和 类模板结合成为函数模板</span>B operator <span class="token operator">+</span> <span class="token punctuation">(</span>Demo <span class="token operator">&lt;</span>B<span class="token operator">></span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> Demo <span class="token operator">&lt;</span>B<span class="token operator">></span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>x <span class="token operator">+</span> b<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**友元函数模板*    类模板中的友元运算符重载函数，在类外部定义时，必须单独说明该函数为一个函数模板*    由于友元函数不是类的成员函数，相当于定义了一个普通的函数模板*    因此，在类中声明时，也必须使用template关键字声明**    友元函数模板 实质是类模板的结合***/</span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Demo <span class="token operator">&lt;</span>int<span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;</span><span class="token operator">&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;</span><span class="token operator">&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*cout:3*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、类继承"><a href="#七、类继承" class="headerlink" title="七、类继承"></a>七、类继承</h2><h3 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7.1、概念"></a>7.1、概念</h3><p>在进行C编程的时候，<code>代码重用的目的就是提高开发效率、减少错误</code>、让大规模代码开发的关注点转到软件结构上。<br>C++(OOP)的代码重用除了简单层次的提供类库,还提出了更高层次：<br>类继承( inheritance)、多态( Polymorphism)、泛型编程( Generic Programming)，等等。</p><p>在C++中,所谓“继承”就是在一个已存在的类的基础上建立一个新的类。</p><p>学生称为基类或父类</p><p>新建如：小学生称为派生类或子类</p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/be673280bva0bd6c7d867d80530e9d8f?fid=1789975539-250528-987681328585093&amp;time=1635296400&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-e5Nh3UcgG3rr0RoAZPW4OtTuyls=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=26281301271095606&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h3 id="7-2、派生一个类"><a href="#7-2、派生一个类" class="headerlink" title="7.2、派生一个类"></a>7.2、派生一个类</h3><h4 id="7-2-1、语法形式"><a href="#7-2-1、语法形式" class="headerlink" title="7.2.1、语法形式"></a>7.2.1、语法形式</h4><pre class="line-numbers language-c++"><code class="language-c++">class子类名:权限访问限定符 基类名1,权限访问限定符 基类名2,...{    //class body};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-2、权限访问符"><a href="#7-2-2、权限访问符" class="headerlink" title="7.2.2、权限访问符"></a>7.2.2、权限访问符</h4><p>c:表示基类的 public/ protected成员可以被子类访问,通过子类对象可访问基类的 oublic成员<br>tected/private:表示基类的 public/ protected.减员可以被子类访问,通过子类对象不能访问基类</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;#define pri() cout <<__func__<<"line:"<<__LINE__<<endl;class Father{public:    double money;     void show() { pri(); }protected:    void  setMoney(double m)    {        money = m;    }private:    int age; };//派生class Son : public Father{    //公有继承public:    void showMoney()    {        money = 120;  //通过子类内部可以识别并访问 公有成员        setMoney(10000);//通过子类内部可以识别并访问 保护成员        //age = 18;  //error： 因为 age 是父类私有成员，能继承，但是不能访问修改    }protected:    int sex; private:    char idCard[18]; };int main(){    /*    Father fa;    fa.setMoney(40000);     cout << fa.money << endl;*/    Son obj; //    obj.money = 20000; //通过子类外部对象访问 父类 继承下来的公有成员于    cout << obj.money <<endl;  //  cout << fa.money << endl;  //父子类  money 是彼此独立 不是共享    obj.show(); //    // obj.setMoney(666);// error:通过子类外部对象访问  父类 的保护成员，不能修改    // obj.age = 18;  //error:通过子类外部对象访问 可以识别到父类私有成员 但是不能访问修改    //    return 0;}/*通过 Father 派生出一个 Son 类，这就算类的派生，Son 类 继承下来的公有成员于 Father类 * * 公有继承： *   1、派生类继承基类的 公有、保护、私有成员 *   2、在类的外部： 通过派生类对象访问公有成员（因为派生继承过来的属性、行为、权限不变） *   3、在类内部：通过成员函数可以访问 基类的公有和保护成员 *   4、私有成员不管类内部、外部都不能访问 *//*cout:20000showline:8*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">/*子类父类重名*/    #include <iostream>using namespace std;class Father{public:    double money;    void show(){        cout << __func__<<__LINE__<<endl;    }};class Son : public Father {public:    double money;    void show(){        cout << __func__<<__LINE__<<endl;    }};int main(){    Son obj;    obj.money = 10000;   // obj.show1();  //    obj.show();  //        obj.Father::money = 20000;    obj.Father::show();    return 0;}/*公有继承时，派生类成员将会隐藏 基类的同名成员 * 即：不能通过派生类对象访问基类成员 *若要访问：可以通过:: 访问被隐藏的基类成员 * *隐藏：作用域不同 函数名相同  参数  返回值可以不同的情况 会是隐藏 *//*cout:show15show7*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">/*保护继承*/#include <iostream>using namespace std;class Father{public:    double money;    void show(){ ; }protected:    void setMoney(double m)    {        money = m;    }private:    int age;};class Son: protected Father{   //保护继承 和私有继承 都不能通过子类外部 对象访问，但是可以通过类内部访问，//class Son: private  Father{    //如果变为 私有继承,那么 该 Son 被再次继承时，不能访问 任何Father 成员成员public:    int showMoney()    {        money = 20;  //公有成员 可以通过类内部访问        setMoney(10000);  //保护 可以通过类内部访问        //age =18;    // 私有 不能访问    }protected:    int x;private:    char idCard[18];};class Son2 :public  Son{public:    int showMoney()    {        money = 20;  //公有成员 可以通过类内部访问        setMoney(10000);  //保护 可以通过类内部访问        //age =18;    // 私有 不能访问    }};int main(){    Son obj;    #if 0    obj.money = 16000;   //通过类的外部对象都不能访问    obj.show();    obj.setMoney(20000);    obj.age = 18;    #endif     return 0;}/*cout:*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有三种继承方式:公有继承、保护继承、私有继承。<br>派生类访问基类的成员的权限如下表所示:</p><p><img src="https://thumbnail0.baidupcs.com/thumbnail/f50a613f5uc29527e90c9f95f410d0fa?fid=1789975539-250528-426817568763585&amp;time=1635303600&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-ec/XTTkcvW8viNLRR77HutZJ+3k=&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=28317448917166343&amp;dp-callid=0&amp;file_type=0&amp;size=c10000_u10000&amp;quality=90&amp;vuk=-&amp;ft=video"></p><h3 id="7-3、派生类的构造及析构"><a href="#7-3、派生类的构造及析构" class="headerlink" title="7.3、派生类的构造及析构"></a>7.3、派生类的构造及析构</h3><p>派生类不能继承基类的构造jc、析构函数。<br>派生类有自己的构造、析构函数。<br>如果基类构造函数有参数,在从派生类的构造函数把参数传递给基类的构造函数。.<br>派生类名∷构造函数名(参数列表):基类名(参数列表) 。</p><ul><li>继承时，构造顺序：先基类构造，再派生构造<br>析构顺序：先派生类析构，再基类构造</li><li>包含对象成员的派生类和基类构造顺序：<br>先 基类构造，再对象成员构造，最后派生类构造</li><li>析构顺序与构造顺序相反</li></ul><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;#define pri() cout << __func__ << "line:"<<__LINE__<< endl;class Base{public:    Base(){pri(); };    Base(int x):x(x) {pri();}    ~Base(){pri(); }    int x;};class Subclass: public Base{public:    //Subclass (int x) :Base(x), a(x)  // 显示调用    Subclass (int x) : a(x)   //隐式调用默认构造    {        pri();    }    ~Subclass(){pri(); }private:    int a;};int main(){    Base b(3);    Subclass s(5);    cout << s.x <<endl;    return 0;}/*    ★★★  *     继承中，定义 派生类对象时，基类和派生类的顺序： *   构造：先基类构造、再派生类构造（实例化对象时，要先实例化基类） *   析构：和构造顺序相反： 先析构派生类 再析构基类 *   *   构造的顺序实现方法： *      1、在派生类构造函数初始化列表 中，隐式调用基类 的默认构造 *      2、如果 基类只有带参的构造函数，那么派生类构造函数初始化列表必须显示调用基类构造 *      3、当基类默认构造函数和带参构造函数同时出现时，派生类中只会调用带参构造，不会默认构造 * */ /*cout:Baseline:8Baseline:7Subclassline:190~Subclassline:21~Baseline:9~Baseline:9*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：类体中显示说明，带参数的构造函数，那么无参数的默认构造 不会自动生成</strong> </p><ul><li>派生类构造函数参数初始化列表中，隐式调用基类 默认构造（无参数的构造函数）</li><li>如果基类出现带参数构造函数，必须在派生类的构造函数参数初始化列表中，显示调用 基类带参构造函数</li><li>如果派生对象成员的构造函数带参数，必须在派生类的构造函数参数初始化列表中，为对象成员这个变量赋初值。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;#define pri() cout << __func__<<"line:"<<__LINE__<<endl;class A{public:   // A(){pri();}    A(int x) {pri();}    ~A(){pri();}};class Base{  //基类public:    Base (int x){pri();}    ~Base(){pri();}};class subclass:public Base{  //派生类public:    subclass():Base(5), x(7), obj(6)    {        pri();    }    ~subclass(){pri();}private:    int x;      A obj; //成员对象，定义时，系统暂时不会自动调用A的构造函数来初始化obj对            };int main(){    subclass s;  //派生对象    return 0;}/*含有对象成员构造顺序：   * 构造顺序： 先基类  再 A 对象 再 派生类   * * 析构顺序：和构造顺序相反 * *//*cout:Baseline:13Aline:7subclassline:22~subclassline:24~Aline:8~Baseline:14*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-4、is-a关系"><a href="#7-4、is-a关系" class="headerlink" title="7.4、is-a关系"></a>7.4、is-a关系</h3><p><strong>is-a关系</strong><br>is-a 一般是继承关系，has-a一般是组合。</p><ul><li>is-a 派生类对象也是一个基类对象，基类对象能够做的操作，派生类也可以</li><li>has-a 是一种聚合，表示一个类中有另一个类的对象。</li></ul><h3 id="7-5、多重继承"><a href="#7-5、多重继承" class="headerlink" title="7.5、多重继承"></a>7.5、多重继承</h3><p> <strong>多重继承的路径二义性：</strong><br>解决方式，作用域访问符 和 设置虚基类（虚继承（继承时有 virtual）共同的基类叫虚基类 </p><pre class="line-numbers language-c++"><code class="language-c++">/*向上向下隐式转换*/#include <iostream>using namespace std;class Base{public:    Base (int x ):x(x)   //这里的 第一次  x = 10     {         cout<< "base" <<__LINE__<<endl;     }    ~Base(){              cout<< "~Base" <<__LINE__<<endl;     }    int x;   };class Subclass:public Base{public:    Subclass(int x, int y): Base(x),y(y){    //初始化 base 的x 为 1 ， subcalss 的y 为 4            cout<< "Subclass" <<__LINE__<<endl;     }    ~Subclass(){        cout<< "~Subclass" <<__LINE__<<endl;     }        int y;};int main(){    Subclass s(1,4);  //派生类对象    #if 0    Base b(10);       //基类对象    cout << b.x << endl;  //结果应该是10        b = s;  // 将 派生类的基类部分重新赋值给 基类对象b， 所以这时候，b对象的数据被 s的基类覆盖了，后边打印b.x             //就不再是 10 而是 1            //c++类型兼容规则：            //公有继承默认小范围转大范围（向上隐士转换）:将派生类中基类的数据进行赋值，派生类自己的部分丢弃       cout << b.x << endl;  //x  为 1    //cout << s.x << endl;   // cout << s.y << endl;   //s  = b;    //基类到 派生的赋值   向下隐式转换   此刻不行#endif     Subclass *q = new Subclass(7,8);    Base *p   = new  Base(9);    p = q;     cout << p->x << endl;    //delete q;    //q = NULL;    // delete p;   // p = NULL;     //    Base *m  = new Subclass(11, 22);    Base &a = s;    cout <<  m->x <<endl;   cout <<  a.x <<endl;    return 0;}/*cout:base8Subclass20base8Subclass20base87base8Subclass20111~Subclass23~Base12*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">/*狼人*/#include <iostream>using namespace std;#define pri()   cout << __func__<<__LINE__<<endl;class Man{public:    Man(){pri();}    ~Man(){pri();}    int x;};class Wolf{public:    Wolf(){pri();}    ~Wolf(){pri();}    int x;};class WolfMan:public Wolf, public Man{public:    WolfMan(){pri();}    ~WolfMan(){pri();}};int main(){    WolfMan wm;    //wm.x  = 100;  //error :有歧义 （x 有二义性）,解决方式 ：作用域 访问符 ：：    wm.Wolf::x = 12;    wm.Man::x  = 13;    return 0;}/*多重继承构造顺序： *  从左边起第一个继承的基类开始构造，再到第二个  再到派生类构造 *  析构顺序：相反 *//*cout:Wolf13Man6WolfMan20~WolfMan21~Man7~Wolf14*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">虚基类#include <iostream>using namespace std;#define pri()   cout << __func__<<__LINE__<<endl;class Animal{public:    Animal(){pri();}    ~Animal(){pri();}    int x;    };class Man: public virtual  Animal {  //在继承的时候 加 virtual声明 为虚继承public:    Man(){pri();}    ~Man(){pri();}};class Wolf :public virtual Animal{public:    Wolf(){pri();}    ~Wolf(){pri();}};class WolfMan:public Wolf, public Man{public:    WolfMan(){pri();}    ~WolfMan(){pri();}};int main(){    WolfMan wm;    wm.x  = 100;  //error :有歧义 （x 有二义性）,解决方式 ：作用域 访问符 ：：    cout << wm.x <<endl;    wm.Wolf::x = 12;    cout << wm.x <<endl;    wm.Man::x  = 13;    cout << wm.x <<endl;    return 0;}/*多重继承构造顺序： *  从左边起第一个继承的基类开始构造，再到第二个  再到派生类构造 *  析构顺序：相反 *//*cout:Animal6Wolf20Man14WolfMan261001213~WolfMan27~Man15~Wolf21~Animal7*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、多态"><a href="#八、多态" class="headerlink" title="八、多态"></a>八、多态</h2><h3 id="8-1、什么是多态"><a href="#8-1、什么是多态" class="headerlink" title="8.1、什么是多态"></a>8.1、什么是多态</h3><p>即多态为: 一种方法,多种实现</p><p>多态（Polymorphism）按字面的意思就是“多种状态”，简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数，是面向对象编程领域的核心概念。<br>即多态为：<code>一种方法，多种实现</code>；<br>多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。<br>在面向对象编程（OOP）的主要特征<br>            封装wrap：实现细节隐藏，使得代码模块化。把成员数据和成员函数封装起来，通过公共的成员接口进行成员数据的操作。<br>            继承inheritance：扩展已存在的代码，目的是为了代码重用<br>            多态polymorphism：目的是为了接口重用。也就是说，不论传递过来的究竟是哪个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;#define pri() cout << __LINE__<<endl;class Base{public:    //void prnmsg(){pri();}    virtual  void prnmsg(){pri();}  //加virtual 关键字声明 为虚函数， 实现多态};class Subclass:public Base{  public:    void prnmsg(){pri();}};void test(Base *obj)  //接口  :多态：一个接口 实现不同的调用方法 {    obj->prnmsg();}int main(){    Base b;  // 基类对象    Subclass s;// 派生类对象    test(&b);  //  调基类     Base obj = b    test(&s);   //调派生类    Base obj = s  //向上隐式转换   还是 Base     /*会不会实现传什么调什么     *在这里  如果不用多态 不能实现传什么调什么  始终调基类     */   // s.prnmsg();  //派生类调用    //s.Base::prnmsg();    return 0;}/*cout:712*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2、虚函数"><a href="#8-2、虚函数" class="headerlink" title="8.2、虚函数"></a>8.2、虚函数</h3><p>有时候,希望子类和基类有相同的方法,但是行为却有所不同,这就是多<br>文里就引入了虚函数的概念。</p><p>有时候，希望子类和基类有相同的方法，但是行为却有所不同，这就是多态。这里就引入了虚函数的概念。<br>注意：简单继承，is-a的关系不是多态；另外函数重载，一般应该是行为类似，使用方法不同，也不是多态。<br>简单地说，用virtual修饰的成员函数，就是虚函数。虚函数的作用就是实现多态性（Polymorphism）。多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。<br>虚函数的限制如下：<br>            A、非类的成员函数不能定义为虚函数<br>            B、类的静态成员函数不能定义为虚函数<br>            C、构造函数不能定义为虚函数，但可以将析构函数定义为虚函数<br>            D、只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时不需要使用关键字“virtual”。<br>            E、当将基类中的某一成员函数声明为虚函数后，派生类中的同名函数（函数名相同、参数列表完全一致、返回值类型相关）自动成为虚函数。</p><h4 id="8-2-1、虚函数语法"><a href="#8-2-1、虚函数语法" class="headerlink" title="8.2.1、虚函数语法"></a>8.2.1、虚函数语法</h4><blockquote><p>class 类名{<br>        public:<br>            virtual 返回值类型 函数名1(参数列表)<br>            {    </p><p>​            }</p><p>​            …</p><p>​        virtual 返回值类型 函数名n(参数列表)<br>​            {</p><p>​            }</p><p>};            </p></blockquote><p>注意：（重点）<br>        虚函数是在运行时根据对象决定调用的函数；</p><h3 id="8-3、覆盖、重载、隐藏"><a href="#8-3、覆盖、重载、隐藏" class="headerlink" title="8.3、覆盖、重载、隐藏"></a>8.3、覆盖、重载、隐藏</h3><p><img src="D:\ZiyuBlogs\source_posts\C++程序设计.assets\1635388364929.png" alt="1635388364929"></p><h3 id="8-4、动态联编-动态链接"><a href="#8-4、动态联编-动态链接" class="headerlink" title="8.4、动态联编(动态链接)"></a>8.4、动态联编(动态链接)</h3><h4 id="8-4-1、联编-链接"><a href="#8-4-1、联编-链接" class="headerlink" title="8.4.1、联编(链接)"></a>8.4.1、联编(链接)</h4><p>就是将模块或者函数合并在一起生成可执行代码的处理过程。按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编。<br>静态联编（静态链接）<br>是指在编译阶段就将函数实现和函数调用关联起来，因此静态联编也叫早绑定。<br>动态联编（动态链接）<br>是指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定。<br>C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了。<br>重载只是一种语言特性，编译器根据函数不同的参数表，把同名函数区分开来，属于静态联编，与多态无关。引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p><h4 id="8-4-2、静态联编-静态链接"><a href="#8-4-2、静态联编-静态链接" class="headerlink" title="8.4.2、静态联编(静态链接)"></a>8.4.2、静态联编(静态链接)</h4><h4 id="8-4-3、动态联编-动态链接"><a href="#8-4-3、动态联编-动态链接" class="headerlink" title="8.4.3、动态联编(动态链接)"></a>8.4.3、动态联编(动态链接)</h4><p><img src="D:\ZiyuBlogs\source_posts\C++程序设计.assets\1635391644517.png" alt="1635391644517"></p><pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>using namespace std;class Base{public:    Base(int x, int b):x(x), b(b){}  //构造函数 参数初始化列表 给成员变量 付初始值    virtual void func1(){        cout << "line: " << __LINE__<<endl;   //虚函数表 成员 func 1 func 2        }    virtual void func2(){        cout << "line: " << __LINE__<<endl;    }    int getX(){ return x; }private:    int x;    //成员变量    int b;    //static int c;  //不占 大小};typedef void (*FUNC)(void);   //函数指针 int main(){    Base obj(10, 20); //定义基类对象  x 和 b  为 2 ，3     cout << "x: " << *((int *)&obj+1) << endl;    //    cout << "b: " << *((int *)&obj+2) << endl;#if 0        FUNC p = (FUNC) *(int *) (*((int *)&obj));    p();    p = (FUNC) *( (int *) (*((int *)&obj))+1);    p();#else        int vtbl = *(int *)&obj;   //obj的头4字节内容  eg：0x12315  这个数据只是16进制数值      FUNC p = (FUNC) *(int *)vtbl;  //将16进制数值强传为 地址 然后取头4个字节内容， 通过 函数指针强转 后调用得到 调用虚函数func1            // vtbl -> 0x1234               p();  //得到 调用虚函数  func 1说明 可以通过虚函数表首地址 第一个成员就算func1的入口地址    p = (FUNC) *((int *)vtbl+1);  //下一个能的得到 func2的调用 更加确定我结论的正确性    p();       cout<< sizeof(obj)<<endl;#endif}/*cout:712*/  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="D:\ZiyuBlogs\source_posts\C++程序设计.assets\1635393220060.png" alt="1635393220060"></p><h3 id="8-5、抽象类"><a href="#8-5、抽象类" class="headerlink" title="8.5、抽象类"></a>8.5、抽象类</h3><p>含有纯虚函数的类就是抽象类。<br>抽象类没有完整的信息,只能是派生类的基类<br>抽象类不能有实例,不能有静态成员<br>派生类应该实现抽象类的所有方法 </p><pre class="line-numbers language-c++"><code class="language-c++">/*纯虚函数*/#include <iostream>using namespace std;class Base{public:   //virtual void  prnmsg() ;  //虚函数   virtual void  prnmsg() = 0;  //纯虚函数(包含纯虚函数的累就是 抽象类)protected:    int y;private:    int x;};class Subclass:public Base{public:    void prnmsg(){        cout <<__LINE__<<endl;         //x = 10;         y = 20;        cout << y << endl;    }};void test (Base &obj){    obj.prnmsg();}int main(){    //Base obj;   //抽象类 不能有具体的实例 可以通过派生类的实现    Subclass obj;     test(obj);    return 0;}/*cout:x: 10b: 20line: 8line: 1112*/ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-6、虚继承"><a href="#8-6、虚继承" class="headerlink" title="8.6、虚继承"></a>8.6、虚继承</h3><p>虚继承解决多重继承产生的二义性；</p><h3 id="8-7、虚析构函数"><a href="#8-7、虚析构函数" class="headerlink" title="8.7、虚析构函数"></a>8.7、虚析构函数</h3><p>一般将析构函数指定为虚的，主要是避免空间回收不完整；</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;#define pri() cout<<__func__<<__LINE__<<endl;class Base{public:    Base() {pri();}    //~Base(){pri();}   virtual  ~Base(){pri();} //声明一个虚析构函数.作用：解决资源回收不完整的情况private:    int x;};class Subclass:public Base{public:    Subclass(){pri();}    ~Subclass(){pri();}private:    int y;};int main(){    Base *p = new Subclass; //     cout<< sizeof(p) <<endl;    delete p;     return 0;}/*Base7Subclass154~Subclass16~Base9*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-8、限制构造函数"><a href="#8-8、限制构造函数" class="headerlink" title="8.8、限制构造函数"></a>8.8、限制构造函数</h3><p>1&gt; 含义<br>        指 构造函数的权限不是publlic,而是protected/private<br>2&gt;友元函数解决限制构造函数不能构造对象的问题</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;#define pri() cout<<__func__<<__LINE__<<endl;class Base{protected:    Base(){pri();}    ~Base(){pri();}public:    void prnmsg()    {        pri();    }    friend Base *getobj();    friend void deleteobj(Base *p)    {        delete p;    }};Base *getobj(){    return (new Base);} class Subclass:public Base{public:    Subclass(){pri();}    ~Subclass(){pri();}};int main(){#if 0    Subclass obj;    obj.prnmsg();#endif        Base *p = getobj();    p->prnmsg();    deleteobj(p);    return 0;}/*cout:Base8prnmsg13~Base9*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-9、类的大小"><a href="#8-9、类的大小" class="headerlink" title="8.9、类的大小"></a>8.9、类的大小</h3><pre class="line-numbers language-c++"><code class="language-c++">/*求类的大小*/#include <iostream>using namespace std;class Base{};class Demo{    char buf[3];  // 4  4    short a;      // 4  2};class Demo1{    double buf[3];  // 24    char a;         //      char b;    //char c;    int f;    short d;};class Demo2{    char a;    double s;     int c;    short b;};class Demo3{  long buf[3];  // 12    char str[9]; // 12    short bu[5];     double a;  //8};class Demo4{    long buf[3];  // 12    char str[9]; // 12    double a;  //8    void setval();   };class Demo5{    virtual void setval(int x){}   // 4   4    virtual void setval2(int x){}  // 0   4    void setval3(int x){}          // 0   0    int x;};class Demo6{    int b;                 // 8   12      static int a;    friend void get(){}    virtual void set(){}    int x;};int Demo6 ::a=13;class Demo7:public Demo6{    };class Demo8:public Demo6, public Demo5{  //12   8       int x;    virtual void fun(){}};class Demo9:public virtual  Demo6, public virtual  Demo5{  //12   8       int x;    int b;   // virtual void fun(){}};int main(){    cout << "sizeof(Base)=" << sizeof(Base) << endl;    cout << "sizeof(Demo)=" << sizeof(Demo) << endl;    cout << "sizeof(Demo1)=" << sizeof(Demo1) << endl;    cout << "sizeof(Demo2)=" << sizeof(Demo2) << endl;    cout << "sizeof(Demo3)=" << sizeof(Demo3) << endl;    cout << "sizeof(Demo4)=" << sizeof(Demo4) << endl;    cout << "sizeof(Demo5)=" << sizeof(Demo5) << endl;    cout << "sizeof(Demo6)=" << sizeof(Demo6) << endl;    cout << "sizeof(Demo7)=" << sizeof(Demo7) << endl;    cout << "sizeof(Demo8)=" << sizeof(Demo8) << endl;    cout << "sizeof(Demo9)=" << sizeof(Demo9) << endl;    return 0;}/*计算类的空间大小 ：类似结构体按字节对齐 *  1、空类 占 1 个字节  （站位符） *  2、成员函数 、静态成员、 友元函数 占 0字节 *  3、虚函数 占 4字节 （仅虚函数表占4字节） *  4、非静态成员 满足字节序对齐 *//*sizeof(Base)=1sizeof(Demo)=6sizeof(Demo1)=36sizeof(Demo2)=20sizeof(Demo3)=40sizeof(Demo4)=32sizeof(Demo5)=8sizeof(Demo6)=12sizeof(Demo7)=12sizeof(Demo8)=24sizeof(Demo9)=32*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="九、异常"><a href="#九、异常" class="headerlink" title="九、异常"></a>九、异常</h2><h3 id="9-1、什么是异常"><a href="#9-1、什么是异常" class="headerlink" title="9.1、什么是异常"></a>9.1、什么是异常</h3><ul><li>什么是异常：异常在一种容错机制，是一种错误处理系统。</li><li>为什么要有异常：保证软件系统运行的稳定性与健状性</li><li>C++的异常处理机制有3部分组成try(检查)→ throw(抛出)&gt; catch(捕获)</li></ul><blockquote><p> try{<br>            //检查语句<br>            if(错误){<br>            throw异常<br>        }<br>}    catch(异常类型1){<br>    进行异常处理的语句1<br>}<br>… </p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <stdexcept>  //标准异常的头文件using namespace std;/*c++ 中默认每一个函数都会抛出异常 除非特殊请说明 * 如果要提示抛出什么类型的异常，那么就必须在函数的声明处 用 throw （。。）说明 * *如果 需要说明该函数没有异常，是安全的函数，则声明定义时，就可以用throw（） 或者 noexecpt来说明 * */int fun(int ,int) throw(invalid_argument);   //告知 编译器或用户 该函数会抛出什么类型的异常int fun(int x ,int y) throw(invalid_argument){    if(!y)  //检查错误        throw invalid_argument("参数有误：y==0"); //抛出异常并携带错误信息（实质是抛出一个类对象）    else        return x/y;    cout << "------------";}int main(){    int a, b;    cin >> a >> b;     try{   //检查错误       cout<<  fun(a,b) << endl;   // }catch ( const invalid_argument &err ){  //捕获异常、定义一个异常类型的对象来接收                                           //通过const 为常量取别名 为 &err         //异常处理（这里是没有自定义处理方式，默认交由上级处理）    }catch (  invalid_argument err ){  //捕获异常、定义一个异常类型的对象来接收  不引用 定义同类类型接收        cout << err.what() <<endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-2、使用标准异常"><a href="#9-2、使用标准异常" class="headerlink" title="9.2、使用标准异常"></a>9.2、使用标准异常</h3><p>C++ 中默认每一个函数都会抛出异常，如果要说明该函数不会抛出异常，那么声明和定义时，都用 throw()<br>如果函数说明为 不会抛出异常，那么内部强行抛出异常，会出现终止程序运行<br>throw() ：是C++ 旧标准的<br>noexcept：是C++ 11 标准中的运算符，32位机中编译时，必须使用 -std=c++0x<br>int func(int, int)throw();</p><h3 id="9-3、自定义异常"><a href="#9-3、自定义异常" class="headerlink" title="9.3、自定义异常"></a>9.3、自定义异常</h3><p>在设计一个大系统的时候,往往设计者会自定义很多错误,这些错误在标准错 误里面是没有的,那么就需要我们来设计一些异常类 </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;#include <stdexcept>#include <string.h>int fun(int , int);int fun(int x, int y){    if(!y)        throw invalid_argument("y==0"); //抛出匿名对象 （没有对象名数据）    else if(y == 1)    {        invalid_argument temp("y==1");         throw temp;     }    else         return x/y;    cout << "------"<<endl;}int main(){    int a,b;LOOP:    cin >> a >> b;    try{        cout << fun(a, b) <<endl;     }catch (const invalid_argument &err){  //捕获方式2种：1、 const 为 常量数据取别名 或 2、定义类类型对象       cout <<  err.what() << endl;        //自定义处理方式        if(strcmp(err.what(), "y==0")  == 0)        {            goto LOOP;        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1635477713189.png" alt="1635477713189"></p><h3 id="9-4、异常规范"><a href="#9-4、异常规范" class="headerlink" title="9.4、异常规范"></a>9.4、异常规范</h3><p> <img src="https://img-blog.csdnimg.cn/b2ace9699a364b47b06261a18d476b20.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDk4MTM3,size_16,color_FFFFFF,t_70" alt="img"> </p><h2 id="十、转换函数"><a href="#十、转换函数" class="headerlink" title="十、转换函数"></a>十、转换函数</h2><h3 id="10-1、什么是转换函数"><a href="#10-1、什么是转换函数" class="headerlink" title="10.1、什么是转换函数"></a>10.1、什么是转换函数</h3><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:    Demo(int x):x(x){}    friend ostream & operator << (ostream & out, Demo &obj)  //运算符重载    {        out << obj.x;        return out;    }private:    int x;};class Base{public:    Base(int x):x(x){}    operator int (){   // 转换函数实现 Base 转 int         return x;    }    operator char(){        return  char(x);    }    operator Demo(){ //Base 转 Demo 都是自定义类型转其他类型， 可用 自己设计的转换函数，但是如果是int * 转int 非自定义类型则要用标准内置转换函数        return x;    }    operator double(){        return double (x);    }private:    int x;};int main(){    int b = 65;    char c = 'B';    c = b;  //内置转换函数（隐式转换）    cout << c << endl;    int a = 13 ;     Base obj(66);    a = obj; //自定义类型转其他类型，自定转换函数    cout << a << endl;  //    char ch = obj ;  //    cout << ch << endl;     Demo D = obj;  // Demo D = Demo(obj);     double m = obj; //     cout << D << endl;     cout << m << endl;     return 0;}/*cout:A66B66*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">4#include <iostream>using namespace std;class Subclass; //前向声明  一个不完整的派生类class Base{public:    Base (int x):x(x){}    operator Subclass(); //转换函数的定义  必须放到派生类定义之后private:    int x;};class Subclass:public Base{public:    Subclass(int x ):x(x), Base (x){}    friend ostream &operator << (ostream &out, Subclass &obj)    {        out << obj.x;        return out;    }private:    int x;};Base :: operator Subclass (){  //转换函数的实现    return x;}int main(){    Subclass a(10);    Base b(6);    // b = a; //right: 向上隐式转换     a = b; // 向下隐式转换 本来是不允许，但是这里自己设计了转换函数可以实现向下转换    cout << a <<endl;  //本来不能直接打印对象，但是这里设计了运算符重载 函数    return 0;}/*cout:6*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-2、标准转换函数"><a href="#10-2、标准转换函数" class="headerlink" title="10.2、标准转换函数"></a>10.2、标准转换函数</h3><p><img src="https://img-blog.csdnimg.cn/d42a91476ea44cb5bc84409c72db3979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDk4MTM3,size_16,color_FFFFFF,t_70"></p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Base{public:    //Base (int x):x(x){}   explicit Base (int x):x(x){}  //限制隐式转换private:    int x;};int main(){    Base obj(1);    //但单参数的构造函数被 explicit 修饰，表示  该类 不能进行隐式转换，否则可以    //Base obj2 = 2; // 构造： Base obj2 = Base(2);     //obj =  1;   //赋值    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Base{public:    Base(int x):x(x){}private:    int x;};class Subclass:public Base{public:    Subclass(int x):x(x), Base(x){}private:    int x;};int main(){    int a = 65;    int *p = &a;    cout << "*p:" << *p <<endl;    cout << "p:" <<  p <<endl;    char *q = reinterpret_cast <char  *>(p);     //q = "hello";    cout << "q:" << q  << endl;    cout << "*q:" << *q  << endl;        int  b = reinterpret_cast <int >(p);     cout << "b:" << b << endl;     const char *str = "hello world";     //char  *s = str;  //error :  str 常量指针 转普通指针     char *buf = const_cast <char *>(str);    // *buf =  'k';    //error：buf指向字符串常量区 不能修改     cout << "buf:" << buf << endl;        Base obj(6);    Subclass *s = static_cast<Subclass * >(&obj);  //static_cast实现 普通类型转换和具有继承关系的转换    //Subclass obj1 = static_cast<Subclass >(obj);         Subclass obj3(3);    Base  obj2 = static_cast<Base >( obj3 );     return 0;}/**p:65p:0xbf99a24cq:A*q:Ab:-1080450484buf:hello world*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-3、自定义转换函数"><a href="#10-3、自定义转换函数" class="headerlink" title="10.3、自定义转换函数"></a>10.3、自定义转换函数</h3><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;class Demo{public:    Demo () {cout << __LINE__<<endl;}    ~Demo () {cout << __LINE__<<endl;}};void test(){    Demo *p = new Demo;    //delete p;  //如果频繁调用，难免忘记 delete 回收，导致内存泄露，但是有智能指针就ok}int main(){    test();        test();    test();    return 0;}/*777*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-4、慎用转换函数"><a href="#10-4、慎用转换函数" class="headerlink" title="10.4、慎用转换函数"></a>10.4、慎用转换函数</h3><h2 id="十一、智能指针"><a href="#十一、智能指针" class="headerlink" title="十一、智能指针"></a>十一、智能指针</h2><h3 id="11-1、什么是智能指针"><a href="#11-1、什么是智能指针" class="headerlink" title="11.1、什么是智能指针"></a>11.1、什么是智能指针</h3><p><img src="https://img-blog.csdnimg.cn/3620129ffce446c4b78c956d4e503828.png"></p><h3 id="11-2、shared-ptI"><a href="#11-2、shared-ptI" class="headerlink" title="11.2、shared-ptI"></a>11.2、shared-ptI</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token number">8</span>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span>   </span><span class="token comment" spellcheck="true">//加头文件</span><span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义一个shared_ptr 智能指针，此处有重载 * 运算符</span>    shared_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">></span> <span class="token function">p</span>   <span class="token punctuation">(</span><span class="token keyword">new</span> Demo<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//编译加 -std=c++0x </span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         shared_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">></span> pp <span class="token operator">=</span> p<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//pp 和 p 共享同一个地址</span>    pp<span class="token operator">-</span><span class="token operator">></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property">#<span class="token directive keyword">if</span> 1</span><span class="token comment" spellcheck="true">//定义的两种方式</span>    shared_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">></span> <span class="token function">q</span>  <span class="token punctuation">(</span><span class="token keyword">new</span> Demo<span class="token punctuation">)</span> <span class="token punctuation">;</span>    shared_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">></span> q2  <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>Demo<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"-------------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-3、unique-ptr"><a href="#11-3、unique-ptr" class="headerlink" title="11.3、unique ptr"></a>11.3、unique ptr</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory></span>   </span><span class="token comment" spellcheck="true">//加头文件</span><span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义一个unique_ptr 智能指针，资源独享 智能指针</span>    unique_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">></span> <span class="token function">p</span>   <span class="token punctuation">(</span><span class="token keyword">new</span> Demo<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//编译加 -std=c++0x </span>    p<span class="token operator">-</span><span class="token operator">></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//unique_ptr&lt;Demo> pp = p;   //不允许pp 和 p 共享同一个地址（独享智能指针）</span>   <span class="token comment" spellcheck="true">// pp->fun();</span> <span class="token macro property">#<span class="token directive keyword">if</span> 0</span><span class="token comment" spellcheck="true">//定义的两种方式</span>    unique_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">></span> <span class="token function">q</span>  <span class="token punctuation">(</span><span class="token keyword">new</span> Demo<span class="token punctuation">)</span> <span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>Demo<span class="token operator">></span> q2  <span class="token operator">=</span> make_unique <span class="token operator">&lt;</span>Demo<span class="token operator">></span> <span class="token punctuation">(</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"-------------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-4、weak-ptr"><a href="#11-4、weak-ptr" class="headerlink" title="11.4、weak-ptr"></a>11.4、weak-ptr</h3><h2 id="十二、STL"><a href="#十二、STL" class="headerlink" title="十二、STL"></a>十二、STL</h2><h3 id="12-1、STL简介"><a href="#12-1、STL简介" class="headerlink" title="12.1、STL简介"></a>12.1、STL简介</h3><h3 id="12-2、标准容器简介"><a href="#12-2、标准容器简介" class="headerlink" title="12.2、标准容器简介"></a>12.2、标准容器简介</h3><h3 id="12-3、vector"><a href="#12-3、vector" class="headerlink" title="12.3、vector"></a>12.3、vector</h3><h3 id="12-4、ist"><a href="#12-4、ist" class="headerlink" title="12.4、ist"></a>12.4、ist</h3><h3 id="12-5、deque"><a href="#12-5、deque" class="headerlink" title="12.5、deque"></a>12.5、deque</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/22/hello-world/"/>
      <url>/2021/10/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
